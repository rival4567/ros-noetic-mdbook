<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>ROS-Noetic-Tutorials</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item "><a href="learn.html"><strong aria-hidden="true">1.</strong> Learn</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="ROS_Basics_with_Turtlesim/main.html"><strong aria-hidden="true">1.1.</strong> ROS Basics with Turtlesim</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="ROS_Basics_with_Turtlesim/ROS_Workspace/main.html"><strong aria-hidden="true">1.1.1.</strong> ROS Workspace</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="ROS_Basics_with_Turtlesim/ROS_Workspace/create_a_catkin_workspace.html"><strong aria-hidden="true">1.1.1.1.</strong> Create a Catkin Workspace</a></li></ol></li><li class="chapter-item "><a href="ROS_Basics_with_Turtlesim/ROS_Package/main.html"><strong aria-hidden="true">1.1.2.</strong> ROS Package</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="ROS_Basics_with_Turtlesim/ROS_Package/create_a_ros_package.html"><strong aria-hidden="true">1.1.2.1.</strong> Create a ROS Package</a></li></ol></li><li class="chapter-item "><a href="ROS_Basics_with_Turtlesim/ROS_Nodes/main.html"><strong aria-hidden="true">1.1.3.</strong> ROS Nodes</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="ROS_Basics_with_Turtlesim/ROS_Nodes/create_a_ros_node.html"><strong aria-hidden="true">1.1.3.1.</strong> Create a ROS Node</a></li><li class="chapter-item "><a href="ROS_Basics_with_Turtlesim/ROS_Nodes/command_rosrun.html"><strong aria-hidden="true">1.1.3.2.</strong> Command: rosrun</a></li><li class="chapter-item "><a href="ROS_Basics_with_Turtlesim/ROS_Nodes/command_rosnode.html"><strong aria-hidden="true">1.1.3.3.</strong> Command: rosnode</a></li></ol></li><li class="chapter-item "><a href="ROS_Basics_with_Turtlesim/ROS_Master/main.html"><strong aria-hidden="true">1.1.4.</strong> ROS Master</a></li><li class="chapter-item "><a href="ROS_Basics_with_Turtlesim/ROS_Parameter_Server/main.html"><strong aria-hidden="true">1.1.5.</strong> ROS Parameter Server</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="ROS_Basics_with_Turtlesim/ROS_Parameter_Server/load_parameters_using_yaml_file.html"><strong aria-hidden="true">1.1.5.1.</strong> Load Parameters using YAML file</a></li><li class="chapter-item "><a href="ROS_Basics_with_Turtlesim/ROS_Parameter_Server/ros_node_to_get_and_set_parameters.html"><strong aria-hidden="true">1.1.5.2.</strong> Example #1: ROS Node to Get and Set Parameters</a></li></ol></li><li class="chapter-item "><a href="ROS_Basics_with_Turtlesim/ROS_Launch_Files/main.html"><strong aria-hidden="true">1.1.6.</strong> ROS Launch Files</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="ROS_Basics_with_Turtlesim/ROS_Launch_Files/create_a_ros_launch_file.html"><strong aria-hidden="true">1.1.6.1.</strong> Create a ROS Launch File</a></li><li class="chapter-item "><a href="ROS_Basics_with_Turtlesim/ROS_Launch_Files/launch_two_ros_nodes.html"><strong aria-hidden="true">1.1.6.2.</strong> Example #1: Launch two ROS Nodes</a></li><li class="chapter-item "><a href="ROS_Basics_with_Turtlesim/ROS_Launch_Files/launch_turtle_in_forest.html"><strong aria-hidden="true">1.1.6.3.</strong> Example #2: Launch Turtle in Forest</a></li><li class="chapter-item "><a href="ROS_Basics_with_Turtlesim/ROS_Launch_Files/load_yaml.html"><strong aria-hidden="true">1.1.6.4.</strong> Example #3: Load YAML</a></li><li class="chapter-item "><a href="ROS_Basics_with_Turtlesim/ROS_Launch_Files/launch_shell_script_and_ros_node.html"><strong aria-hidden="true">1.1.6.5.</strong> Example #4: Launch Shell Script and ROS Node</a></li></ol></li><li class="chapter-item "><a href="ROS_Basics_with_Turtlesim/ROS_Communication/main.html"><strong aria-hidden="true">1.1.7.</strong> ROS Communication</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="ROS_Basics_with_Turtlesim/ROS_Communication/ROS_Topics/main.html"><strong aria-hidden="true">1.1.7.1.</strong> ROS Topics</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="ROS_Basics_with_Turtlesim/ROS_Communication/ROS_Topics/command_rostopic/main.html"><strong aria-hidden="true">1.1.7.1.1.</strong> Command: rostopic</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="ROS_Basics_with_Turtlesim/ROS_Communication/ROS_Topics/command_rostopic/list.html"><strong aria-hidden="true">1.1.7.1.1.1.</strong> list</a></li><li class="chapter-item "><a href="ROS_Basics_with_Turtlesim/ROS_Communication/ROS_Topics/command_rostopic/type_info_and_rosmsg.html"><strong aria-hidden="true">1.1.7.1.1.2.</strong> type, info and rosmsg</a></li><li class="chapter-item "><a href="ROS_Basics_with_Turtlesim/ROS_Communication/ROS_Topics/command_rostopic/pub.html"><strong aria-hidden="true">1.1.7.1.1.3.</strong> pub</a></li><li class="chapter-item "><a href="ROS_Basics_with_Turtlesim/ROS_Communication/ROS_Topics/command_rostopic/echo.html"><strong aria-hidden="true">1.1.7.1.1.4.</strong> echo</a></li></ol></li><li class="chapter-item "><a href="ROS_Basics_with_Turtlesim/ROS_Communication/ROS_Topics/pub_sub_with_custom_message.html"><strong aria-hidden="true">1.1.7.1.2.</strong> Example #1: Pub-Sub with Custom Message</a></li></ol></li><li class="chapter-item "><a href="ROS_Basics_with_Turtlesim/ROS_Communication/ROS_Services/main.html"><strong aria-hidden="true">1.1.7.2.</strong> ROS Services</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="ROS_Basics_with_Turtlesim/ROS_Communication/ROS_Services/create_a_srv_file.html"><strong aria-hidden="true">1.1.7.2.1.</strong> Create a srv file</a></li><li class="chapter-item "><a href="ROS_Basics_with_Turtlesim/ROS_Communication/ROS_Services/test_ros_services_server_and_client.html"><strong aria-hidden="true">1.1.7.2.2.</strong> Test ROS Services - Server and Client</a></li></ol></li><li class="chapter-item "><a href="ROS_Basics_with_Turtlesim/ROS_Communication/ROS_Actions/main.html"><strong aria-hidden="true">1.1.7.3.</strong> ROS Actions</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="ROS_Basics_with_Turtlesim/ROS_Communication/ROS_Actions/create_a_action_message_file.html"><strong aria-hidden="true">1.1.7.3.1.</strong> Create an action message file</a></li><li class="chapter-item "><a href="ROS_Basics_with_Turtlesim/ROS_Communication/ROS_Actions/simple_action_server_and_client.html"><strong aria-hidden="true">1.1.7.3.2.</strong> Simple Action Server &amp; Client</a></li><li class="chapter-item "><a href="ROS_Basics_with_Turtlesim/ROS_Communication/ROS_Actions/action_server_and_client.html"><strong aria-hidden="true">1.1.7.3.3.</strong> Action Server &amp; Client</a></li><li class="chapter-item "><a href="ROS_Basics_with_Turtlesim/ROS_Communication/ROS_Actions/ros_actions_walkthrough_videos.html"><strong aria-hidden="true">1.1.7.3.4.</strong> ROS Actions Walkthrough Videos</a></li></ol></li></ol></li><li class="chapter-item "><a href="ROS_Basics_with_Turtlesim/ROS_TF/main.html"><strong aria-hidden="true">1.1.8.</strong> ROS TF</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="ROS_Basics_with_Turtlesim/ROS_TF/ros_tf_using_turtlesim.html"><strong aria-hidden="true">1.1.8.1.</strong> ROS tf using turtlesim</a></li></ol></li><li class="chapter-item "><a href="ROS_Basics_with_Turtlesim/Miscellaneous/main.html"><strong aria-hidden="true">1.1.9.</strong> Miscellaneous</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="ROS_Basics_with_Turtlesim/Miscellaneous/rqt_graph.html"><strong aria-hidden="true">1.1.9.1.</strong> Rqt_graph</a></li><li class="chapter-item "><a href="ROS_Basics_with_Turtlesim/Miscellaneous/plot_juggler.html"><strong aria-hidden="true">1.1.9.2.</strong> Plot juggler</a></li><li class="chapter-item "><a href="ROS_Basics_with_Turtlesim/Miscellaneous/ros_bags.html"><strong aria-hidden="true">1.1.9.3.</strong> ROS Bags</a></li></ol></li></ol></li><li class="chapter-item "><a href="Additional_Sections/main.html"><strong aria-hidden="true">1.2.</strong> Additional Sections</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="Additional_Sections/configuring_your_ros_environment.html"><strong aria-hidden="true">1.2.1.</strong> Configuring your ROS environment</a></li><li class="chapter-item "><a href="Additional_Sections/introducing_turtlesim_and_rqt.html"><strong aria-hidden="true">1.2.2.</strong> Introducing turtlesim and rqt</a></li><li class="chapter-item "><a href="Additional_Sections/ros_nodes.html"><strong aria-hidden="true">1.2.3.</strong> Understanding ROS nodes</a></li><li class="chapter-item "><a href="Additional_Sections/ros_topics.html"><strong aria-hidden="true">1.2.4.</strong> Understanding ROS topics</a></li><li class="chapter-item "><a href="Additional_Sections/ros_services.html"><strong aria-hidden="true">1.2.5.</strong> Understanding ROS services</a></li></ol></li></ol></li><li class="chapter-item "><a href="tasks/main.html"><strong aria-hidden="true">2.</strong> Tasks</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="tasks/task0/main.html"><strong aria-hidden="true">2.1.</strong> Task0</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="tasks/task0/turtle-task.html"><strong aria-hidden="true">2.1.1.</strong> Problem Statement</a></li><li class="chapter-item "><a href="tasks/task0/expected-output.html"><strong aria-hidden="true">2.1.2.</strong> Expected Output</a></li><li class="chapter-item "><a href="tasks/task0/recording-logs.html"><strong aria-hidden="true">2.1.3.</strong> Recording Logs</a></li><li class="chapter-item "><a href="tasks/task0/solution.html"><strong aria-hidden="true">2.1.4.</strong> Solution</a></li><li class="chapter-item "><a href="tasks/task0/autoeval.html"><strong aria-hidden="true">2.1.5.</strong> Autoeval script</a></li></ol></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">ROS-Noetic-Tutorials</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                        

                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="learn"><a class="header" href="#learn">Learn</a></h1>
<ul>
<li>In this section you will find all the necessary learning resources needed.</li>
</ul>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="ros-basics-with-turtlesim"><a class="header" href="#ros-basics-with-turtlesim">ROS Basics with Turtlesim</a></h1>
<h2 id="nothing-to-show-here"><a class="header" href="#nothing-to-show-here">Nothing to show here.</a></h2>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="catkin-workspace"><a class="header" href="#catkin-workspace">Catkin Workspace</a></h1>
<ul>
<li><strong>catkin</strong> is the official build system of ROS and the successor to the original ROS build system, rosbuild.</li>
<li><strong>catkin</strong> combines CMake macros and Python scripts to provide some functionality on top of CMake's normal workflow.</li>
<li>catkin was designed to be more conventional than rosbuild, allowing for better distribution of packages, better cross-compiling support, and better portability.</li>
</ul>
<h2 id="src"><a class="header" href="#src">src</a></h2>
<ul>
<li>the <code>src</code> folder contains the source code of catkin packages. This is where you can extract/checkout/clone source code for the packages you want to build.</li>
<li>Each folder within the <code>src</code> folder contains one or more catkin packages. This folder should remain unchanged by configuring, building, or installing.</li>
<li>The root of the <code>src</code> folder contains a symbolic link to catkin's boiler-plate 'toplevel' CMakeLists.txt file. This file is invoked by CMake during the configuration of the catkin projects in the workspace. It can be created by calling <code>catkin_init_workspace</code> in the <code>src</code> folder directory. When we execute the <code>catkin_make</code> command from the workspace folder, it checks inside the <code>src</code> folder and builds each package.</li>
</ul>
<h2 id="build"><a class="header" href="#build">build</a></h2>
<ul>
<li>The <code>build</code> folder is where CMake is invoked to <code>build</code> the catkin packages in the <code>src</code> folder.</li>
<li>CMake and catkin keep their cache information and other intermediate files here.</li>
<li>The <code>build</code> folder does not have to be contained within the workspace nor does it have to be outside of the <code>src</code> folder, but this is recommended.</li>
</ul>
<h2 id="devel"><a class="header" href="#devel">devel</a></h2>
<ul>
<li>The development folder (or <code>devel</code> folder) is where built targets are placed before installed.</li>
<li>The way targets are organized in the <code>devel</code> folder is the same as their layout when they are installed.</li>
<li>This provides a useful testing and development environment which does not require invoking the installation step.</li>
<li>The location of the <code>devel</code> folder is controlled by a catkin specific CMake variable called <code>CATKIN_DEVEL_PREFIX</code>, and it defaults to build/devel folder.</li>
<li>This is the default behavior because it might be confusing to CMake users if they invoked CMake in a <code>build</code> folder and that modified things outside of the current directory.</li>
<li>It is recommended, however, to set the <code>devel</code> folder directory to be a peer of the <code>build</code> folder directory.</li>
</ul>
<pre><code class="language-bash">source ~/&lt;workspace_name&gt;/devel/setup.bash
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="create-a-catkin-workspace"><a class="header" href="#create-a-catkin-workspace">Create a Catkin Workspace</a></h1>
<ol>
<li>Open up the terminal <code>shortcut key: ctrl+alt+t</code>.</li>
<li>Create the root workspace directory. You can name your directory anything we are using <code>workspace</code> as the name this time.</li>
</ol>
<pre><code class="language-bash">cd ~/
mkdir -p ~/workspace/src
cd workspace
</code></pre>
<ol start="3">
<li>Run the following command:</li>
</ol>
<pre><code class="language-bash">catkin_make
</code></pre>
<ol start="4">
<li>The catkin_make command is a convenience tool for working with catkin workspaces. Running it the first time in your workspace, it will create a CMakeLists.txt link in your 'src' folder.</li>
<li>Additionally, if you look in your current directory you should now have a 'build' and 'devel' folder.</li>
</ol>
<pre><code class="language-bash">ls
</code></pre>
<ol start="6">
<li>Now to make your workspace visible to ROS. Source the setup file in the devel directory.</li>
</ol>
<pre><code class="language-bash">source ~/catkin_ws/devel/setup.bash
</code></pre>
<p>By doing this, all the packages that you create inside the <code>src</code> folder will be visible to ROS.
7. This <code>setup.bash</code> file of your workspace must be source everytime when you want to use ROS packages created inside this workspace.</p>
<ol start="8">
<li>To make sure your workspace is properly overlayed by the setup script, make sure ROS_PACKAGE_PATH environment variable includes the directory you're in.</li>
</ol>
<pre><code class="language-bash">echo $ROS_PACKAGE_PATH
/home/youruser/catkin_ws/src:/opt/ros/kinetic/share
</code></pre>
<hr>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="ros-package"><a class="header" href="#ros-package">ROS Package</a></h1>
<ul>
<li>ROS Packages according to ROS Wiki</li>
</ul>
<blockquote>
<p>Software in ROS is organized in packages. A package might contain ROS nodes, a ROS-independent library, a dataset, configuration files, a third-party piece of software, or anything else that logically constitutes a useful module. The goal of these packages it to provide this useful functionality in an easy-to-consume manner so that software can be easily reused. In general, ROS packages follow a "Goldilocks" principle: enough functionality to be useful, but not too much that the package is heavyweight and difficult to use from other software.</p>
</blockquote>
<hr>
<h3 id="reference"><a class="header" href="#reference">Reference</a></h3>
<ol>
<li><a href="http://wiki.ros.org/Packages">Packages</a></li>
</ol>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="create-a-ros-package"><a class="header" href="#create-a-ros-package">Create a ROS Package</a></h1>
<ul>
<li>This tutorial will demonstrate how to use the <code>catkin_create_pkg</code> script to create a new catkin package, and what you can do with it after it has been created.</li>
</ul>
<ol>
<li>
<p>First, navigate to the source space directory of the catkin workspace you've created.</p>
<pre><code class="language-bash">cd ~/catkin_ws/src
</code></pre>
</li>
<li>
<p>Now, use the catkin_create_pkg script to create a new package called pkg_ros_basics which depends on std_msgs, roscpp, and rospy:</p>
<pre><code class="language-bash">catkin_create_pkg pkg_ros_basics std_msgs rospy roscpp
</code></pre>
<ul>
<li>
<p>This will create a beginner_tutorials folder which contains a <code>package.xml</code> and a <code>CMakeLists.txt</code>, which have been partially filled out with the information you gave <code>catkin_create_pkg</code>.</p>
</li>
<li>
<p><code>catkin_create_pkg</code> requires that you give it a <code>package_name</code> and optionally a list of dependencies on which that package depends:</p>
<pre><code class="language-bash">catkin_create_pkg &lt;package_name&gt; [depend1] [depend2] [depend3]
</code></pre>
</li>
</ul>
</li>
<li>
<p>Now, you need to build the packages in the catkin workspace:</p>
<pre><code class="language-bash">cd ~/catkin_ws
catkin build
</code></pre>
</li>
</ol>
<ul>
<li>Inside the package, there are <code>src</code> folder, <code>package.xml</code>, <code>CMakeLists.txt</code>, and the <code>include</code> folders.
<ul>
<li><strong>CMakeLists.txt</strong>: This file has all the commands to build the ROS source code inside the package and create the executable. For more information about CMakeLists visit <a href="http://wiki.ros.org/catkin/CMakeLists.txt">here</a>.</li>
<li><strong>package.xml</strong>: This is an XML file. It mainly contains the package dependencies, information, and so forth.</li>
<li><strong>src</strong>: The source code of ROS packages are kept in this folder.</li>
</ul>
</li>
</ul>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="ros-nodes"><a class="header" href="#ros-nodes">ROS Nodes</a></h1>
<ul>
<li>
<p>A ROS Node is a piece of software/executable that uses ROS to communicate with other ROS Nodes.</p>
</li>
<li>
<p>ROS Nodes are building block of any ROS Application.</p>
</li>
<li>
<p>For example, if you have a wall-following robot then one ROS Node could get distance sensor values and another node can control the motors of the robot. So, these two nodes will communicate with each other in order to move the robot.</p>
</li>
<li>
<p>You can write your entire ROS Application in a single node but having multiple nodes ensures that if a node crashes it won't crash your entire ROS application.</p>
</li>
<li>
<p>In this eYRC Theme your job will be to write suitable ROS Nodes for your ROS Application.</p>
</li>
<li>
<p>A ROS package can have multiple ROS Nodes.</p>
</li>
<li>
<p>Python and C++ are majorly used to write ROS Nodes.</p>
</li>
<li>
<p>In this eYRC Theme we will use Python to write ROS Nodes.</p>
</li>
</ul>
<hr>
<h3 id="reference-1"><a class="header" href="#reference-1">Reference</a></h3>
<ol>
<li><a href="http://wiki.ros.org/ROS/Tutorials/UnderstandingNodes">ROS WIki - Undertanding Nodes</a></li>
</ol>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="create-a-ros-node"><a class="header" href="#create-a-ros-node">Create a ROS Node</a></h1>
<p>In this section we will learn how to create a ROS Node inside <code>pkg_ros_basics</code> ROS Package which we created in the previous section.</p>
<ol>
<li>
<p>Navigate to <code>pkg_ros_basics</code>.</p>
<pre><code class="language-bash">cd ~/catkin_ws/src/pkg_ros_basics
</code></pre>
<p>OR</p>
<pre><code class="language-bash">roscd pkg_ros_basics
</code></pre>
<p><strong>NOTE</strong>: <code>roscd</code> will work only if you have sourced <code>setup.bash</code> of your catkin workspace.</p>
</li>
<li>
<p>Create a <code>scripts</code> folder for your Python scripts and navigate into the folder.</p>
<pre><code class="language-bash">mkdir scripts
cd scripts
</code></pre>
</li>
<li>
<p>Create a Python script called <code>node_hello_ros.py</code>.</p>
<pre><code class="language-bash">touch node_hello_ros.py
</code></pre>
</li>
<li>
<p>Open the script in any text-editor and start editing.</p>
<pre><code class="language-bash">gedit node_hello_ros.py
</code></pre>
</li>
<li>
<p>First line of all your Python ROS scripts should be the following shebang</p>
<pre><code class="language-bash">#!/usr/bin/env python
</code></pre>
</li>
<li>
<p>Now write a ROS Node to print <code>Hello World!</code> on the console.</p>
<pre><code class="language-python">#!/usr/bin/env python

import rospy


def main():    

# 1. Make the script a ROS Node.
rospy.init_node('node_hello_ros', anonymous=True)

# 2. Print info on console.
rospy.loginfo(&quot;Hello World!&quot;)

# 3. Keep the node alive till it is killed by the user.
rospy.spin()


if __name__ == '__main__':
    try:
        main()
    except rospy.ROSInterruptException:
        pass
</code></pre>
</li>
<li>
<p>Now you have to make this script an executable.</p>
<pre><code class="language-bash">sudo chmod +x node_hello_ros.py
</code></pre>
</li>
<li>
<p>Now in order to run your ROS Node,</p>
<ol>
<li>
<p>Open up a terminal and run ROS Master.</p>
<pre><code class="language-bash">roscore
</code></pre>
</li>
<li>
<p>Once the roscore is up running, open a new termminal and run the ROS Node.</p>
<pre><code class="language-bash">rosrun pkg_ros_basics node_hello_ros.py

</code></pre>
<p><strong>NOTE</strong>: This command will work only if you have sourced <code>setup.bash</code> of your catkin workspace either manually or using <code>.bashrc</code>.</p>
</li>
</ol>
</li>
<li>
<p>You should get some output like this,</p>
<pre><code class="language-bash">[INFO] [1601277063.968749]: Hello World!
</code></pre>
</li>
</ol>
<hr><div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="command-rosrun"><a class="header" href="#command-rosrun">Command: rosrun</a></h1>
<p><code>rosrun</code> allows you to run an executable in an arbitrary package from anywhere without having to give its full path or cd/roscd there first.</p>
<p>Usage:</p>
<pre><code class="language-bash">rosrun &lt;package&gt; &lt;executable&gt;
</code></pre>
<p><code>&lt;package&gt;</code> is nothing but the package name which you have created using <code>catkin_create_pkg</code> command or used any other package.</p>
<p><code>&lt;executable&gt;</code> is the python or cpp file.</p>
<h2 id="to-create-an-executable-python-file"><a class="header" href="#to-create-an-executable-python-file">To create an executable python file</a></h2>
<p>After creating a package, create a folder in the package names as <code>scripts</code> folder to store all the python files in that folder.</p>
<pre><code class="language-bash">cd ~/catkin_ws/src/&lt;package&gt;
mkdir scripts
</code></pre>
<p>Here we can create python scripts by running this command by going into the <code>scripts</code> directory,</p>
<pre><code class="language-bash">cd scripts
touch filename.py
</code></pre>
<p>Now you can edit your python file and before running you have to make it executable by running this command once,</p>
<pre><code class="language-bash">cd ~/catkin_ws/src/&lt;package&gt;/scripts
chmod +x filename.py
</code></pre>
<h2 id="to-create-an-executable-cpp-file"><a class="header" href="#to-create-an-executable-cpp-file">To create an executable cpp file</a></h2>
<p>After creating a package, create a folder in the package names as <code>src</code> folder to store all the cpp files in that folder.</p>
<pre><code class="language-bash">cd ~/catkin_ws/src/&lt;package&gt;
mkdir src
</code></pre>
<p>Here we can create cpp files by running this command by going into the <code>src</code> directory,</p>
<pre><code class="language-bash">cd src
touch filename.cpp
</code></pre>
<p>Now you can edit your cpp file , but for making it executable we have to edit the <code>CMakeLists.txt</code> file which is present in the package.</p>
<p>Add these few lines at the bottom of <code>CMakeLists.txt</code> file,</p>
<pre><code class="language-txt">add_executable(filename src/filename.cpp)
target_link_libraries(filename ${catkin_LIBRARIES})

</code></pre>
<p>Then run this command,</p>
<pre><code class="language-bash">cd ~/catkin_ws
catkin build
</code></pre>
<hr><div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="command-rosnode"><a class="header" href="#command-rosnode">Command: rosnode</a></h1>
<p><code>rosnode</code> contains the rosnode command-line tool for displaying debug information about <a href="http://wiki.ros.org/Nodes">ROS Nodes</a>.</p>
<blockquote>
<p> Note: For quick information about any command, be that outside of ROS, simply type the command along with suffix `--h` or `-help`. This is a widely used concept among other Linux commands for quick references. Here's an example for `rosnode --h` command
</p>
</blockquote>
<p><img src="ROS_Basics_with_Turtlesim/ROS_Nodes/rosnode_1.png" alt="image" /></p>
<h2 id="list"><a class="header" href="#list">list</a></h2>
<p><code>rosnode list</code> displays a list of all current nodes.</p>
<p>Let's figure out what argument the <code>list</code> sub-command needs. In a new terminal run start the rosmaster:</p>
<pre><code class="language-bash">roscore
</code></pre>
<p>And in another terminal, run:</p>
<pre><code class="language-bash">rosrun rospy_tutorials talker
</code></pre>
<p>And in another terminal, run:</p>
<pre><code class="language-bash">rosnode list
</code></pre>
<p>Now the node named <code>talker</code>(node with word talker in it) will be printed on the terminal.
<img src="ROS_Basics_with_Turtlesim/ROS_Nodes/rosnode_list.png" alt="image" /></p>
<h2 id="info"><a class="header" href="#info">info</a></h2>
<p><code>rosnode info /node_name</code> displays information about a node, including publications and subscriptions.</p>
<p>Let's figure out what argument the <code>info</code> sub-command needs. In a new terminal run start the rosmaster:</p>
<pre><code class="language-bash">roscore
</code></pre>
<p>And in another terminal, run:</p>
<pre><code class="language-bash">rosrun rospy_tutorials talker
</code></pre>
<p>And in another terminal, run:</p>
<pre><code class="language-bash">rosnode info &lt;talker_node&gt;
</code></pre>
<p>This should give details related to the particular node as shown below:</p>
<p><img src="ROS_Basics_with_Turtlesim/ROS_Nodes/rosnode_info.png" alt="image" /></p>
<h2 id="kill"><a class="header" href="#kill">kill</a></h2>
<p>IMPORTANT: rosnode kill is not guaranteed to succeed. Let's figure out what argument the <code>kill</code> sub-command needs. In a new terminal run start the rosmaster:</p>
<pre><code class="language-bash">roscore
</code></pre>
<p>And in another terminal, run:</p>
<pre><code class="language-bash">rosrun rospy_tutorials talker
</code></pre>
<p>And in another terminal, run:</p>
<pre><code class="language-bash">rosnode kill rosout &lt;talker_node&gt;

</code></pre>
<p><img src="ROS_Basics_with_Turtlesim/ROS_Nodes/rosnode_kill.png" alt="image" /></p>
<p>Interactive mode. This enables you to select which node to kill from a numbered list, which is useful for killing anonymous nodes.</p>
<pre><code class="language-bash">rosnode kill
1. /rosout

Please enter the number of the node you wish to kill.
</code></pre>
<hr><div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="ros-master"><a class="header" href="#ros-master">ROS Master</a></h1>
<ul>
<li>
<p>The ROS Master provides naming and registration services to the rest of the nodes in the ROS system.</p>
</li>
<li>
<p>As you know ROS Nodes are building blocks of any ROS Application. A single ROS Application may have multiple ROS Nodes which communicate with each other. </p>
</li>
<li>
<p>The role of the ROS Master is to enable individual ROS nodes to locate one another.</p>
</li>
<li>
<p>Once these nodes have located each other they communicate with each other peer-to-peer.</p>
</li>
<li>
<p>You can say, communication is established between nodes by the ROS Master. So, without ROS Master running ROS Nodes can not communicate with each other.</p>
</li>
</ul>
<h2 id="start-ros-master"><a class="header" href="#start-ros-master">Start ROS Master</a></h2>
<p>To start ROS Master you just have to enter the following command in the terminal.</p>
<pre><code class="language-bash">roscore
</code></pre>
<p><img src="ROS_Basics_with_Turtlesim/ROS_Master/./ROS_Basics_with_Turtlesim/ROS_Master/ros-master.png" alt="ros-master.png" /></p>
<p><code>roscore</code> is a collection of nodes and programs that are pre-requisites of a ROS-based system. You must have a roscore running in order for ROS nodes to communicate.</p>
<p>So <a href="http://wiki.ros.org/roscore">roscore</a> will start the following:</p>
<ol>
<li>ROS Master</li>
<li>ROS Parameter Server</li>
<li><code>rosout</code> Logging Node</li>
</ol>
<p>In the preceding output, you can see information about the computer, parameter which list the name (noetic) and version number of ROS distribution, and some other information.</p>
<h2 id="reading-assignment"><a class="header" href="#reading-assignment">Reading Assignment</a></h2>
<ol>
<li><a href="http://wiki.ros.org/Master">ROS Wiki - Master</a></li>
<li><a href="http://wiki.ros.org/roscore">ROS Wiki - roscore</a></li>
</ol>
<hr />
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="ros-parameter-server"><a class="header" href="#ros-parameter-server">ROS Parameter Server</a></h1>
<ul>
<li>
<p>You can think Parameter Server as a space where all the necessary data that needs to be shared among various ROS Nodes is stored.</p>
</li>
<li>
<p>Parameter Server runs inside ROS Master.</p>
</li>
<li>
<p>ROS Nodes can view and even modify data stored in the Parameter Server.</p>
</li>
<li>
<p>Typically Parameter Server is used to store configuration parameters.</p>
</li>
</ul>
<h2 id="reading-assignment-1"><a class="header" href="#reading-assignment-1">Reading Assignment</a></h2>
<ol>
<li><a href="http://wiki.ros.org/Parameter%20Server">ROS Wiki - Parameter Server</a></li>
</ol>
<hr />
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="load-parameters-using-yaml-file"><a class="header" href="#load-parameters-using-yaml-file">Load Parameters using YAML file</a></h1>
<p>In this section we will learn how to load your own parameters in ROS Parameter Server using a YAML File.</p>
<h2 id="steps"><a class="header" href="#steps">Steps</a></h2>
<ol>
<li>
<p>Navigate to <code>pkg_ros_basics</code>.</p>
<pre><code class="language-bash">cd ~/workspace/src/pkg_ros_basics
</code></pre>
<p>OR</p>
<pre><code class="language-bash">roscd pkg_ros_basics
</code></pre>
<blockquote>
<p><strong>NOTE</strong>: <code>roscd</code> will work only if you have sourced <code>setup.bash</code> of your catkin workspace.</p>
</blockquote>
</li>
<li>
<p>Create a <code>config</code> folder for your Python scripts and navigate into the folder.</p>
<pre><code class="language-bash">mkdir config
cd config
</code></pre>
</li>
<li>
<p>Create a configuration YAML file called <code>config_my.yaml</code>.</p>
<pre><code class="language-bash">touch config_my.yaml
</code></pre>
</li>
<li>
<p>Open the script in any text-editor and start editing.</p>
<pre><code class="language-bash">gedit config_my.yaml
</code></pre>
</li>
<li>
<p>Now fill your config file.</p>
<pre><code class="language-yaml"># Comment: config_my.yaml Configuration
details:
    name:
        first: &quot;Heisenberg&quot; # First Name
        last: &quot;White&quot; # Last Name
     contact:
         address: &quot;ABQ Street, ABQ&quot; # Address
         phone: 77777    # Contact
</code></pre>
<center><a href="ROS_Basics_with_Turtlesim/ROS_Parameter_Server/./ROS_Basics_with_Turtlesim/ROS_Parameter_Server/config_my.yaml" download><button>Download</button></a></center>
<ul>
<li>
<p>ROS Build system will create a Python Dictionary called <code>details</code>.</p>
</li>
<li>
<p>This dictionary will have two keys,</p>
<ol>
<li>Dictionary <code>name</code></li>
<li>Dictionary <code>contact</code></li>
</ol>
</li>
<li>
<p>In your ROS Node you can use <code>rospy</code> to get parameters stored in this <code>config_my</code> dictionary.</p>
<pre><code class="language-python">param_config_my = rospy.get_param('details')

first_name = param_config_my['name']['first']
phone = param_config_my['contact']['phone']
</code></pre>
</li>
</ul>
<br />
</li>
<li>
<p>Now if you want to load the parameters defined in the YAML file you have to first start the ROS Parameter Server.</p>
<p>Open up a new terminal and enter the following.</p>
<pre><code class="language-bash">roscore
</code></pre>
</li>
<li>
<p>Now load your parameters.</p>
<pre><code class="language-bash">rosparam load config_my.yaml
</code></pre>
</li>
<li>
<p>Now get the list of parameters loaded in your ROS Parameter Server.</p>
<pre><code class="language-bash">rosparam list
</code></pre>
<p>Output:</p>
<pre><code class="language-bash">/details/contact/address
/details/contact/phone
/details/name/first
/details/name/last
/rosdistro
/roslaunch/uris/host_ros_noetic__35261
/rosversion
/run_id
</code></pre>
<p>Here you can see the first four parameters are loaded from our <code>config_my.yaml</code> file.</p>
</li>
<li>
<p>Now to view the content of any parameter do the following.</p>
<pre><code class="language-bash">rosparam get /details/contact/phone
</code></pre>
<p>Output:</p>
<pre><code class="language-bash">77777
</code></pre>
<p>This is the value which we defined in the <code>config_my.yaml</code> file.</p>
<p><img src="ROS_Basics_with_Turtlesim/ROS_Parameter_Server/./ROS_Basics_with_Turtlesim/ROS_Parameter_Server/rosparam-load-config_my.png" alt="rosparam-load-config_my.png" /></p>
</li>
</ol>
<hr />
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="example-1-ros-node-to-get-and-set-parameters"><a class="header" href="#example-1-ros-node-to-get-and-set-parameters">Example #1: ROS Node to Get and Set Parameters</a></h1>
<h2 id="aim"><a class="header" href="#aim">Aim</a></h2>
<p>To write a ROS Node to read <code>config_my.yaml</code> file loaded in ROS Parameter Server (<a href="ROS_Basics_with_Turtlesim/ROS_Parameter_Server/./ROS_Basics_with_Turtlesim/ROS_Parameter_Server/load_parameters_using_yaml_file.html#Load-Parameters-using-YAML-file">done here</a>), print it on the console and modify the phone number.</p>
<h2 id="code"><a class="header" href="#code">Code</a></h2>
<p><code>node_param_get_set.py</code></p>
<pre><code class="language-python">#!/usr/bin/env python3

import rospy


def main():    
    
    # 1. Make the script a ROS Node.
    rospy.init_node('node_param_get_set', anonymous=True)

    # 2. Read from Parameter Server
    rospy.loginfo(&quot;Reading from Parameter Server.&quot;)

    
    param_config_my = rospy.get_param('details')    # Get all the parameters inside 'details'

    # Store the parameters in variables
    first_name = param_config_my['name']['first']
    last_name = param_config_my['name']['last']
    address = param_config_my['contact']['address']
    phone = param_config_my['contact']['phone']

    # Print the parameters
    rospy.loginfo(&quot;&gt;&gt; First Name: {}&quot;.format(first_name))
    rospy.loginfo(&quot;&gt;&gt; Last Name: {}&quot;.format(last_name))
    rospy.loginfo(&quot;&gt;&gt; Address: {}&quot;.format(address))
    rospy.loginfo(&quot;&gt;&gt; Phone: {}&quot;.format(phone))

    # 3. Modify the Phone Number 

    rospy.set_param('/details/contact/phone', 55555)        # Modify only Phone Number in Parameter Server
    new_phone = rospy.get_param('/details/contact/phone')   # Get only Phone Number from Parameter Server
    rospy.loginfo(&quot;&gt;&gt; New Phone: {}&quot;.format(new_phone))     # Print the new Phone Number
    

if __name__ == '__main__':
    try:
        main()
    except rospy.ROSInterruptException:
        pass
</code></pre>
<center><a href="ROS_Basics_with_Turtlesim/ROS_Parameter_Server/./ROS_Basics_with_Turtlesim/ROS_Parameter_Server/node_param_get_set.py" download><button>Download</button></a></center>
<br />
<blockquote>
<p><strong>NOTE</strong>: Make sure you make the <code>pkg_ros_basics node_param_get_set.py</code> script executable.</p>
</blockquote>
<p>Output:</p>
<pre><code class="language-bash">rosrun pkg_ros_basics node_param_get_set.py
</code></pre>
<p><img src="ROS_Basics_with_Turtlesim/ROS_Parameter_Server/./ROS_Basics_with_Turtlesim/ROS_Parameter_Server/node-param-get-set-output.png" alt="node-param-get-set-output.png" /></p>
<ul>
<li>The code is self-explanatory.</li>
<li>If you are not able to understand the code feel free to seek help from us.</li>
</ul>
<hr />
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="ros-launch-files"><a class="header" href="#ros-launch-files">ROS Launch Files</a></h1>
<ul>
<li>
<p>In the previous sections you must have noticed that we need to use <code>roscore</code> command to start ROS Master and Parameter Server, <code>rosrun</code> command to run a ROS Node, <code>rosparam load</code> command to load parameters etc.</p>
</li>
<li>
<p>This is a tedious process to manually run nodes and load parameters.</p>
</li>
<li>
<p>Launch files provides the capability to do all these stuff using a single command.</p>
</li>
<li>
<p>The idea is to mention all the nodes that you want to run, all the config file that you want to load etc. in a single file which you can run using <code>roslaunch</code> command.</p>
</li>
</ul>
<h2 id="reading-assignment-2"><a class="header" href="#reading-assignment-2">Reading Assignment</a></h2>
<ol>
<li><a href="http://wiki.ros.org/roslaunch">ROS Wiki - roslaunch</a></li>
</ol>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="create-a-ros-launch-file"><a class="header" href="#create-a-ros-launch-file">Create a ROS Launch File</a></h1>
<h2 id="roslaunch-command"><a class="header" href="#roslaunch-command">roslaunch Command</a></h2>
<ul>
<li>
<p><code>roslaunch</code> is a tool for easily launching multiple ROS nodes locally and remotely via SSH. </p>
</li>
<li>
<p>It includes options to automatically respawn processes that have already died. <code>roslaunch</code> takes in one or more XML configuration files (with the .launch extension) that specify the parameters to set and nodes to launch.</p>
</li>
<li>
<p>Usage:</p>
<pre><code class="language-bash">roslaunch &lt;package&gt; file.launch
</code></pre>
<p><code>&lt;package&gt;</code> is nothing but the package name which you have created using <code>catkin_create_pkg</code> command or used any other package.</p>
</li>
</ul>
<h2 id="steps-to-create-a-launch-file"><a class="header" href="#steps-to-create-a-launch-file">Steps to create a launch file</a></h2>
<ol>
<li>
<p>After creating a package, create a folder in the package names as a <code>launch</code> folder to store all the launch files in that folder.</p>
<pre><code class="language-bash">cd ~/catkin_ws/src/&lt;package&gt;
mkdir launch
</code></pre>
</li>
<li>
<p>Here we can create launch files by running this command by going into the <code>launch</code> directory, we can keep any name for the launch file,</p>
<pre><code class="language-bash">cd launch
touch filename.launch
</code></pre>
<p>Now you can edit your launch file by adding different nodes that you have to run simultaneously.</p>
</li>
</ol>
<h2 id="steps-to-add-a-ros-node-in-the-launch-file"><a class="header" href="#steps-to-add-a-ros-node-in-the-launch-file">Steps to add a ROS node in the launch file</a></h2>
<ol>
<li>
<p>Launch files always starts with</p>
<pre><code class="language-xml">&lt;launch&gt;
</code></pre>
<p>and end with</p>
<pre><code class="language-xml">&lt;/launch&gt;
</code></pre>
</li>
<li>
<p>Now to add any executable file which we have seen in the rosrun_command section, we have to add this line,</p>
<pre><code class="language-xml">&lt;node pkg=&quot;name_of_package&quot; type=&quot;name_of_executable.py&quot; name=&quot;name_of_executable&quot; 
output=&quot;screen&quot;/&gt;
</code></pre>
<ul>
<li><code>pkg</code> is the package name which you have created</li>
<li><code>type</code> is the name of executable file</li>
<li><code>name</code> is the name of the node which is created in that executable</li>
<li><code>output</code> means it will print the data given to the roslog command</li>
</ul>
</li>
</ol>
<h2 id="steps-to-load-config-yaml-file-in-ros-parameter-server"><a class="header" href="#steps-to-load-config-yaml-file-in-ros-parameter-server">Steps to load Config YAML file in ROS Parameter Server</a></h2>
<ul>
<li>You can use <code>rosparam</code> tag to load the YAML file.
<pre><code class="language-xml">&lt;rosparam file =&quot;$(find name_of_package)/config/config.yaml&quot;/&gt;
</code></pre>
<ul>
<li><code>name_of_package</code> is the name of your ROS package.</li>
<li><code>config.yaml</code> is the name of your configuration file.</li>
</ul>
</li>
</ul>
<h2 id="steps-to-add-a-shell-script-in-the-launch-file"><a class="header" href="#steps-to-add-a-shell-script-in-the-launch-file">Steps to add a Shell Script in the launch file</a></h2>
<ul>
<li>
<p>You can use <code>node</code> tag to run any shell script using launch file</p>
<pre><code class="language-xml">&lt;node pkg=&quot;name_of_package&quot; type=&quot;shell_script.sh&quot; name=&quot;shell_script&quot; output=&quot;screen&quot;&gt;
        &lt;param name=&quot;cmd&quot; value=&quot;$(find name_of_package)/launch/shell_script.sh&quot;/&gt;
&lt;/node&gt;
</code></pre>
<ul>
<li><code>name_of_package</code> is the name of your ROS package.</li>
<li><code>shell_script.sh</code> is the name of your configuration file.</li>
<li><code>/launch/shell_script.sh</code> is the location of the shell script inside your ROS Package folder.</li>
</ul>
</li>
</ul>
<hr />
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="example-1-launch-two-ros-nodes"><a class="header" href="#example-1-launch-two-ros-nodes">Example #1: Launch two ROS Nodes</a></h1>
<h2 id="aim-1"><a class="header" href="#aim-1">Aim</a></h2>
<ul>
<li>To launch <code>talker</code> and <code>listener</code> node present in <code>rospy_tutorials</code> package.</li>
<li>For this create a <code>chatter.launch</code> file and save it in the <code>launch</code> folder inside <code>pkg_ros_basics</code> package.</li>
</ul>
<blockquote>
<p><strong>NOTE</strong>: To install <code>rospy_tutorials</code> package in your system you can run <code>sudo apt-get install ros-noetic-ros-tutorials</code> this command.</p>
</blockquote>
<p>Once installed, you can use <code>listener</code> python script and talker executable written in C++ present in <code>rospy_tutorials</code> package.</p>
<h2 id="code-1"><a class="header" href="#code-1">Code</a></h2>
<p><code>chatter.launch</code></p>
<pre><code class="language-xml">&lt;launch&gt;
  &lt;node name=&quot;talker&quot; pkg=&quot;rospy_tutorials&quot; type=&quot;talker&quot; output=&quot;screen&quot;/&gt;
  &lt;node name=&quot;listener&quot; pkg=&quot;rospy_tutorials&quot; type=&quot;listener.py&quot; output=&quot;screen&quot;/&gt;
&lt;/launch&gt;
</code></pre>
<center><a href="ROS_Basics_with_Turtlesim/ROS_Launch_Files/ROS_Basics_with_Turtlesim/ROS_Launch_Files/chatter.launch" download><button>Download</button></a></center>
<ul>
<li>Here first <code>talker.cpp</code> file (for cpp file we dont need to add .cpp extension) has been included with the node name as talker and also set output as screen so you can see the output from talker node.</li>
<li>Next we have added <code>listener.py</code> which has node name as listener and here also we have set output as screen.</li>
</ul>
<h2 id="run-command"><a class="header" href="#run-command">Run Command</a></h2>
<p>Now run these command to run the launch file,</p>
<pre><code class="language-bash">roslaunch pkg_ros_basics chatter.launch
</code></pre>
<h2 id="output"><a class="header" href="#output">Output</a></h2>
<h2 id="img-srcros_basics_with_turtlesimros_launch_filesros_basics_with_turtlesimros_launch_fileschatterpng-altchatterpng-"><a class="header" href="#img-srcros_basics_with_turtlesimros_launch_filesros_basics_with_turtlesimros_launch_fileschatterpng-altchatterpng-"><img src="ROS_Basics_with_Turtlesim/ROS_Launch_Files/./ROS_Basics_with_Turtlesim/ROS_Launch_Files/chatter.png" alt="chatter.png" /></a></h2>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="example-2-launch-turtle-in-forest"><a class="header" href="#example-2-launch-turtle-in-forest">Example #2: Launch Turtle in Forest</a></h1>
<h2 id="aim-2"><a class="header" href="#aim-2">Aim</a></h2>
<ul>
<li>
<p>To write a launch file to run <code>turtlesim_node</code> node and <code>turtle_teleop_key</code> node present in <code>turtlesim</code> package.</p>
</li>
<li>
<p>While launching the <code>turtlesim_node</code> make sure to change the background colour of the simulator from blue to forest green.</p>
</li>
<li>
<p>Name the launch file <code>turtlesim.launch</code> and save it in <code>launch</code> folder inside <code>pkg_ros_basics</code> package.</p>
</li>
</ul>
<h2 id="code-2"><a class="header" href="#code-2">Code</a></h2>
<p><code>turtlesim.launch</code></p>
<pre><code class="language-xml">&lt;launch&gt;
    
    &lt;node pkg=&quot;turtlesim&quot; type=&quot;turtlesim_node&quot; name=&quot;node_turtlesim_node&quot;&gt;
        &lt;param name=&quot;/background_r&quot; value=&quot;34&quot; /&gt;
        &lt;param name=&quot;/background_g&quot; value=&quot;139&quot; /&gt;
        &lt;param name=&quot;/background_b&quot; value=&quot;34&quot; /&gt;
    &lt;/node&gt;
    
    &lt;node pkg=&quot;turtlesim&quot; type=&quot;turtle_teleop_key&quot; name=&quot;node_turtle_teleop_key&quot; /&gt;

&lt;/launch&gt;
</code></pre>
<center><a href="ROS_Basics_with_Turtlesim/ROS_Launch_Files/ROS_Basics_with_Turtlesim/ROS_Launch_Files/turtlesim.launch" download><button>Download</button></a></center>
<h2 id="run-command-1"><a class="header" href="#run-command-1">Run Command</a></h2>
<pre><code class="language-bash">roslaunch pkg_ros_basics turtlesim.launch
</code></pre>
<h2 id="output-1"><a class="header" href="#output-1">Output</a></h2>
<p><img src="ROS_Basics_with_Turtlesim/ROS_Launch_Files/./ROS_Basics_with_Turtlesim/ROS_Launch_Files/turtlesim.png" alt="turtlesim.png" /></p>
<br />
- The code is self-explanatory.
- If you are not able to understand the code feel free to seek help from us.
---<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="example-3-load-yaml"><a class="header" href="#example-3-load-yaml">Example #3: Load YAML</a></h1>
<h2 id="aim-3"><a class="header" href="#aim-3">Aim</a></h2>
<ul>
<li>To write a launch file to load <code>config_my.yaml</code> present in <code>pkg_ros_basics</code> package.</li>
<li>Also launch the <code>node_param_get_set.py</code> ROS node after loading the YAML file.</li>
</ul>
<h2 id="code-3"><a class="header" href="#code-3">Code</a></h2>
<p><code>load_yaml.launch</code></p>
<pre><code class="language-xml">&lt;launch&gt;
    
    &lt;rosparam file =&quot;$(find pkg_ros_basics)/config/config_my.yaml&quot;/&gt;
        
    &lt;node pkg=&quot;pkg_ros_basics&quot; type=&quot;node_param_get_set.py&quot; name=&quot;node_param_get_set&quot; output=&quot;screen&quot;/&gt;

&lt;/launch&gt;
</code></pre>
<center><a href="ROS_Basics_with_Turtlesim/ROS_Launch_Files/ROS_Basics_with_Turtlesim/ROS_Launch_Files/load_yaml.launch" download><button type="button">Download</button></a></center>
<h2 id="run-command-2"><a class="header" href="#run-command-2">Run Command</a></h2>
<pre><code class="language-bash">roslaunch pkg_ros_basics load_yaml.launch
</code></pre>
<h2 id="output-2"><a class="header" href="#output-2">Output</a></h2>
<p><img src="ROS_Basics_with_Turtlesim/ROS_Launch_Files/./ROS_Basics_with_Turtlesim/ROS_Launch_Files/load_yaml.png" alt="load_yaml.png" /></p>
<br />
- The code is self-explanatory.
- If you are not able to understand the code feel free to seek help from us.
---<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="example-4-launch-shell-script-and-ros-node"><a class="header" href="#example-4-launch-shell-script-and-ros-node">Example #4: Launch Shell Script and ROS Node</a></h1>
<h2 id="aim-4"><a class="header" href="#aim-4">Aim</a></h2>
<ul>
<li>
<p>To write a launch file called <code>web_node.launch</code> to open <code>e-yantra.org</code> in firefox and run <code>node_hello_ros.py</code> of <code>pkg_ros_basics</code>.</p>
</li>
<li>
<p>You need to write a shell script called <code>webpage_launch.sh</code> to open <code>e-yantra.org</code> in firefox and save it in <code>launch</code> folder of <code>pkg_ros_basics</code>.</p>
</li>
</ul>
<h2 id="code-4"><a class="header" href="#code-4">Code</a></h2>
<p><code>webpage_launch.sh</code></p>
<pre><code class="language-shell">#!/bin/bash

# Store URL in a variable
URL1=&quot;https://www.e-yantra.org/&quot;

# Print some message
echo &quot;** Opening $URL1 in Firefox **&quot;

# Use firefox to open the URL in a new window
firefox -new-window $URL1 
</code></pre>
<center><a href="ROS_Basics_with_Turtlesim/ROS_Launch_Files/ROS_Basics_with_Turtlesim/ROS_Launch_Files/webpage_launch.sh" download><button>Download</button></a></center>
<p><code>node_hello_ros.py</code></p>
<pre><code class="language-python">#!/usr/bin/env python3

import rospy

def main():
    # 1. Make the script a ROS Node.
    rospy.init_node('node_hello_ros', anonymous=True)

    # 2. Print Hello World!
    rospy.loginfo(&quot;Hello World!&quot;)

if __name__ == '__main__':
    try:
        main()
    except rospy.ROSInterruptException:
        pass
</code></pre>
<center><a href="ROS_Basics_with_Turtlesim/ROS_Launch_Files/ROS_Basics_with_Turtlesim/ROS_Launch_Files/node_hello_ros.py" download><button>Download</button></a></center>
<blockquote>
<p><strong>NOTE</strong>: You need to make these shell script and python script executable using <code>chmod</code> before using it in a launch file.</p>
</blockquote>
<p><code>web_node.launch</code></p>
<pre><code class="language-xml">&lt;launch&gt;
    
    &lt;node pkg=&quot;pkg_ros_basics&quot; type=&quot;webpage_launch.sh&quot; name=&quot;webpage_launch&quot; output=&quot;screen&quot;&gt;
        &lt;param name=&quot;cmd&quot; value=&quot;$(find pkg_ros_basics)/launch/webpage_launch.sh&quot;/&gt;
    &lt;/node&gt;
        
    &lt;node pkg=&quot;pkg_ros_basics&quot; type=&quot;node_hello_ros.py&quot; name=&quot;node_hello_ros&quot; output=&quot;screen&quot;/&gt;

&lt;/launch&gt;
</code></pre>
<center><a href="ROS_Basics_with_Turtlesim/ROS_Launch_Files/ROS_Basics_with_Turtlesim/ROS_Launch_Files/web_node.launch" download="web_node.launch"><button type="button">Download</button></a></center>
<h2 id="run-command-3"><a class="header" href="#run-command-3">Run Command</a></h2>
<pre><code class="language-bash">roslaunch pkg_ros_basics web_node.launch
</code></pre>
<h2 id="output-3"><a class="header" href="#output-3">Output</a></h2>
<p><img src="ROS_Basics_with_Turtlesim/ROS_Launch_Files/./ROS_Basics_with_Turtlesim/ROS_Launch_Files/web_node.png" alt="web_node.png" /></p>
<br />
- The code is self-explanatory.
- If you are not able to understand the code feel free to seek help from us.
---<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="ros-communication"><a class="header" href="#ros-communication">ROS Communication</a></h1>
<ul>
<li>
<p>In ROS there are essentially three ways in which two nodes can communicate with each other. These are,</p>
<ol>
<li>ROS Topics</li>
<li>ROS Services</li>
<li>ROS Actions</li>
</ol>
</li>
<li>
<p>We will learn about all these three in this section.</p>
</li>
</ul>
<hr />
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="ros-topics"><a class="header" href="#ros-topics">ROS Topics</a></h1>
<ul>
<li>
<p>ROS Topics allow <strong>unidirectional</strong> communication between ROS Nodes.</p>
</li>
<li>
<p>When using ROS Topics a ROS Node can be a <strong>publisher</strong>, <strong>subscriber</strong> or both.</p>
</li>
<li>
<p>A ROS Node acting as a publisher can publish data on a ROS Topic and a subscriber ROS Node can subscribe to a ROS Topic.</p>
</li>
<li>
<p>Publisher and Subscriber Nodes will exchange ROS Messages over a ROS Topic.</p>
</li>
<li>
<p>A ROS Message is a simple data structure, comprising typed fields (integer, floating point, boolean, etc.). So a ROS Message can hold data of various data-types.</p>
</li>
<li>
<p>Consider this analogy,</p>
<ul>
<li>
<p>Let's say you are subscribed to a newspaper called <em>The Noetic</em> published by a publishing house called <em>OSRF</em>.</p>
</li>
<li>
<p>Every morning your paperboy <em>Jon Doe</em> will deliver this newspaper to you.</p>
</li>
<li>
<p>You like <em>The Noetic</em> because it has dedicated section on <em>sports</em> and <em>robotics</em> news.</p>
</li>
<li>
<p>In this analogy you can think,</p>
<ul>
<li>
<p><code>OSRF &lt;--&gt; ROS Publisher Node</code></p>
<p>OSRF which is publishing the newspaper as a Publisher Node.</p>
</li>
<li>
<p><code>You &lt;--&gt; ROS Subscriber Node</code></p>
<p>You along with your neighbours who are subscribed to this newspaper as Subscriber Nodes. </p>
</li>
<li>
<p><code>Jon Doe &lt;--&gt; ROS Topic</code></p>
<p>Your paperboy who is taking the newspaper from the publisher and delivering it to its subscribers as a ROS Topic.</p>
</li>
<li>
<p><code>The Noetic Newspaper &lt;--&gt; ROS Message</code></p>
<p>The physical newspaper is your ROS Message.</p>
</li>
<li>
<p><code>Sports and Robotics Sections of The Noetic &lt;--&gt; Data Fields defined in ROS Message</code></p>
<p>The sections of the newspaper is the Data Fields defined in the ROS Message.</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="reading-assignment-3"><a class="header" href="#reading-assignment-3">Reading Assignment</a></h2>
<ol>
<li><a href="http://wiki.ros.org/Topics">ROS Wiki - Topic</a></li>
<li><a href="http://wiki.ros.org/Messages">ROS Wiki - Messages</a></li>
</ol>
<hr />
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="command-rostopic"><a class="header" href="#command-rostopic">Command: rostopic</a></h1>
<p><code>rostopic</code> contains the rostopic command-line tool for displaying debug information about ROS Topics, including publishers, subscribers, publishing rate, and ROS Messages.</p>
<blockquote>
<p>Reference: <a href="http://wiki.ros.org/rostopic">http://wiki.ros.org/rostopic</a></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>: For quick information about any command, be that outside of ROS, simply type the command along with suffix <code>--h</code> or <code>-help</code>. This is a widely used concept among other Linux commands for quick referencing. Here's an example for <code>rostopic --h</code> command </p>
</blockquote>
<p><img src="ROS_Basics_with_Turtlesim/ROS_Communication/ROS_Topics/command_rostopic/./ROS_Basics_with_Turtlesim/ROS_Communication/ROS_Topics/rostopic--h.png" alt="rostopic--h" /></p>
<p>As you can see in the above image, there are multiple suffixes associated with <code>rostopic</code>, these suffixes are the commands to analyze any existing or developing system. We'll look into this sub-command or suffixes one by one. </p>
<hr />
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="list-1"><a class="header" href="#list-1">list</a></h1>
<ul>
<li>
<p><code>rostopic list</code> returns a list of all topics currently subscribed to and published.</p>
</li>
<li>
<p>Let's see this command's actual output. In a new terminal start the roscore:</p>
<pre><code class="language-bash">roscore
</code></pre>
<blockquote>
<p><strong>Note</strong>: Do not close this terminal, otherwise you won't be able to communicate with the rosmaster while executing some of its features.</p>
</blockquote>
</li>
<li>
<p>And in another terminal, run:</p>
<pre><code class="language-bash">rostopic list
</code></pre>
<p>This should give something like the following image, which is the ROS's default topics. </p>
<p><img src="ROS_Basics_with_Turtlesim/ROS_Communication/ROS_Topics/command_rostopic/./ROS_Basics_with_Turtlesim/ROS_Communication/ROS_Topics/command_rostopic/rostopic_list_before.png" alt="rostopic-list-before.png" /></p>
</li>
<li>
<p>For this tutorial, we will also use turtlesim. Please run in a new terminal: </p>
<pre><code class="language-bash">rosrun turtlesim turtlesim_node
</code></pre>
<p>You will see a small blue box with probably a different turtle within it. </p>
<p><img src="ROS_Basics_with_Turtlesim/ROS_Communication/ROS_Topics/command_rostopic/./ROS_Basics_with_Turtlesim/ROS_Communication/ROS_Topics/command_rostopic/turtlesim_node.png" alt="turtlesim-node.png" /></p>
</li>
<li>
<p>Now, check again the <code>rostopic list</code> command in another terminal and observe the topics being subscribed or published.</p>
<p><img src="ROS_Basics_with_Turtlesim/ROS_Communication/ROS_Topics/command_rostopic/./ROS_Basics_with_Turtlesim/ROS_Communication/ROS_Topics/command_rostopic/rostopic_list_after.png" alt="rostopic-list-after.png" /></p>
<blockquote>
<p><strong>Note</strong>: You can know more about these listed topics, by simply adding arguments as a suffix to <code>rostopic list</code>. And to know which arguments does what type <code>rostopic list --help</code>. Go ahead and experiment.</p>
</blockquote>
<hr />
</li>
</ul>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="type-info-and-rosmsg"><a class="header" href="#type-info-and-rosmsg">type, info and rosmsg</a></h1>
<h2 id="type"><a class="header" href="#type">type</a></h2>
<p>Communication on topics happens by sending ROS messages between <a href="http://wiki.ros.org/Nodes">nodes</a>. To communicate, the publisher and subscriber must send and receive the same <strong>type</strong> of message. This means that a topic <strong>type</strong> is defined by the message <strong>type</strong> published on it. The <strong>type</strong> of the message sent on a topic can be determined using <code>rostopic type</code>. </p>
<pre><code class="language-bash">rostopic type [topic]
</code></pre>
<ul>
<li>
<p>From the previous section, we know that the turtlesim node has 3 topics being published/subscribed. </p>
<ul>
<li><code>/turtle1/cmd_vel</code></li>
<li><code>/turtle1/pose</code></li>
<li><code>/turtle1/color_sensor</code></li>
</ul>
</li>
<li>
<p>Lets consider the topics <code>/turtle1/cmd_vel</code>. Enter the following command to get the message type.</p>
<pre><code class="language-bash">rostopic type /turtle1/cmd_vel
</code></pre>
<p><img src="ROS_Basics_with_Turtlesim/ROS_Communication/ROS_Topics/command_rostopic/./ROS_Basics_with_Turtlesim/ROS_Communication/ROS_Topics/command_rostopic/rostopic-type.png" alt="rostopic-type.png" /></p>
</li>
</ul>
<h2 id="rosmsg"><a class="header" href="#rosmsg">rosmsg</a></h2>
<ul>
<li>
<p>As you can observe the type of message associated with <code>/turtle1/cmd_vel</code> is <code>geometry_msgs/Twist</code>. let's look into more detail of the message, using <code>rosmsg show [messageType]</code> command: </p>
<pre><code class="language-bash">rosmsg show geometry_msgs/Twist
</code></pre>
<p><img src="ROS_Basics_with_Turtlesim/ROS_Communication/ROS_Topics/command_rostopic/./ROS_Basics_with_Turtlesim/ROS_Communication/ROS_Topics/command_rostopic/rosmsg-show.png" alt="rosmsg-show.png" /></p>
</li>
<li>
<p>A message consists of two parts, <em>field and constant</em>. Simply, <strong>fields</strong> is the datatype and <strong>constants</strong> are the representative value. From the above figure, you can observe that these <em>field and constants</em> are displayed twice. However, both of these sections, are separate since they have a different <strong>header</strong> or different sub-information from the same robot. The 2 <strong>headers</strong> seen are...</p>
<ul>
<li>
<p><code>geometry_msgs/Vector3 linear:</code> Describes the linear velocities of all the 3 axes.</p>
</li>
<li>
<p><code>geometry_msgs/Vector3 angular:</code> While this header describes, angular velocities of all 3 axes.</p>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>For more details regarding <em>messages</em> in ROS refer to <a href="http://wiki.ros.org/msg">wiki.ros.org/msg</a>.</p>
</blockquote>
<blockquote>
<p>For more information on <code>geometry_msgs/Twist</code> refer, this <a href="https://stackoverflow.com/questions/50976281/what-do-x-y-and-z-mean-in-geometry-msgs-twist-message-in-ros">thread</a> of Stackoverflow forum.</p>
</blockquote>
<h2 id="info-1"><a class="header" href="#info-1">info</a></h2>
<ul>
<li>This command provides a little more detail about topics then <code>type</code> argument. </li>
</ul>
<pre><code class="language-bash">rostopic info /turtle1/cmd_vel
</code></pre>
<ul>
<li>
<p>The output of this command will yield both</p>
<ul>
<li>the message <strong>type</strong> and</li>
<li>the nodes which are publishing it or subscribing it.</li>
</ul>
</li>
</ul>
<p><img src="ROS_Basics_with_Turtlesim/ROS_Communication/ROS_Topics/command_rostopic/./ROS_Basics_with_Turtlesim/ROS_Communication/ROS_Topics/command_rostopic/rostopic-info.png" alt="rostopic-info.png" /></p>
<hr />
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="pub"><a class="header" href="#pub">pub</a></h1>
<ul>
<li>
<p><code>rostopic pub</code> publishes data on to a topic currently advertised. </p>
</li>
<li>
<p>Usage:</p>
</li>
</ul>
<pre><code class="language-bash">rostopic pub [topic] [msg_type] [args]
</code></pre>
<ul>
<li>Let's move the turtle inside the turtlsim window.</li>
</ul>
<pre><code class="language-bash">rostopic pub /turtle1/cmd_vel geometry_msgs/Twist &quot;linear:
x: 0.0 
y: 0.0
z: 0.0
angular:
x: 0.0
y: 0.0
z: 0.0&quot;
</code></pre>
<blockquote>
<p>Here we recommend to double tap the TAB button after <code>/turtle1/cmd_vel</code> (don't forget the space after the topic name). You'll see the message <strong>type</strong> appearing after a few instance. Similarly, double tapping after 'geometry_msgs/Twist' will make the corresponding message content appear automatically. Try it with other commands too.</p>
</blockquote>
<p><img src="ROS_Basics_with_Turtlesim/ROS_Communication/ROS_Topics/command_rostopic/./ROS_Basics_with_Turtlesim/ROS_Communication/ROS_Topics/command_rostopic/rostopic-pub-0.png" alt="rostopic-pub-0.png" /></p>
<ul>
<li>Now that we have the complete blank (with all <em>constants</em> as zeros) pub command for <code>/turtle1/cmd_vel</code>, let's rotate it about its z-axis (Yep! the Omega variable).</li>
</ul>
<pre><code class="language-bash">rostopic pub /turtle1/cmd_vel geometry_msgs/Twist &quot;linear:
x: 0.0 
y: 0.0
z: 0.0
angular:
x: 0.0
y: 0.0
z: 0.5
</code></pre>
<ul>
<li>After executing the above command you will see the turtle rotating clockwise. </li>
</ul>
<p><img src="ROS_Basics_with_Turtlesim/ROS_Communication/ROS_Topics/command_rostopic/./ROS_Basics_with_Turtlesim/ROS_Communication/ROS_Topics/command_rostopic/rostopic-pub-0.5.png" alt="rostopic-pub-0.5.png" /></p>
<ul>
<li>
<p>However, the turtle only rotated for a while and not continuously. This is because our <code>pub</code> command was only sent once. So, to keep the turtle rotating we need to keep sending our <code>pub</code> command repeatedly. And to do so, we'll use the <code>-r</code> argument with <code>pub</code> command.</p>
</li>
<li>
<p>The following command is used to publish a steady stream of commands at a rate of 10Hz.</p>
</li>
</ul>
<pre><code class="language-bash">rostopic pub -r 10 /turtle1/cmd_vel geometry_msgs/Twist &quot;linear:
x: 2.0
y: 0.0
z: 0.0
angular:
x: 0.0
y: 0.0
z: 1.8&quot;
</code></pre>
<p><img src="ROS_Basics_with_Turtlesim/ROS_Communication/ROS_Topics/command_rostopic/./ROS_Basics_with_Turtlesim/ROS_Communication/ROS_Topics/command_rostopic/rostopic-pub-rate-10.gif" alt="rostopic-pub-rate-10.gif" /></p>
<ul>
<li>You can always know more about <code>pub</code> command by simply typing <code>rostopic pub --help</code>.</li>
</ul>
<blockquote>
<p>For more details refer, <a href="http://wiki.ros.org/rostopic#rostopic_pub">http://wiki.ros.org/rostopic#rostopic_pub</a></p>
</blockquote>
<hr />
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="echo"><a class="header" href="#echo">echo</a></h1>
<ul>
<li>
<p><code>rostopic echo</code> shows the data published on a topic. </p>
</li>
<li>
<p>Usage:</p>
</li>
</ul>
<pre><code class="language-bash">rostopic echo [topic]
</code></pre>
<ul>
<li>
<p>In the earlier section, at the end, we used <code>-r</code> argument to keep it rotation at an angular velocity of 0.5 units. But what if the velocity is unknown and we need this information as feedback to control the motion of turtle???</p>
</li>
<li>
<p>Our desire here is to get the pose information or simply one or all of the turtle's x,y, and z values w.r.t to the world.</p>
</li>
<li>
<p>But let's see if there is any data being published by the turtlesim node in the first place. To do so, we'll use the following command...</p>
</li>
</ul>
<pre><code class="language-bash">rostopic list -p
</code></pre>
<p><img src="ROS_Basics_with_Turtlesim/ROS_Communication/ROS_Topics/command_rostopic/./ROS_Basics_with_Turtlesim/ROS_Communication/ROS_Topics/command_rostopic/rostopic-list-p.png" alt="rostopic-list-p.png" /></p>
<ul>
<li>
<p>From the <code>-p</code> we know 2 topic is being published</p>
<ul>
<li><code>/turtle1/color_sensor</code></li>
<li><code>/turtle1/pose</code></li>
</ul>
</li>
<li>
<p>Let's see more into the <code>/turtle1/pose</code> topic. </p>
</li>
</ul>
<p><img src="ROS_Basics_with_Turtlesim/ROS_Communication/ROS_Topics/command_rostopic/./ROS_Basics_with_Turtlesim/ROS_Communication/ROS_Topics/command_rostopic/rostopic-info-turtle1-pose.png" alt="rostopic-info-turtle1-pose.png" /></p>
<ul>
<li>
<p>Luckily the pose information of turtle from the turtlesim is being published on the topic <code>/turtle1/pose</code>. </p>
</li>
<li>
<p>To display the pose data, enter the following command...</p>
</li>
</ul>
<pre><code class="language-bash">rostopic echo /turtle1/pose
</code></pre>
<p><img src="ROS_Basics_with_Turtlesim/ROS_Communication/ROS_Topics/command_rostopic/./ROS_Basics_with_Turtlesim/ROS_Communication/ROS_Topics/command_rostopic/rostopic-echo.png" alt="rostopic-echo.png" /></p>
<hr />
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="example-1-pub-sub-with-custom-message"><a class="header" href="#example-1-pub-sub-with-custom-message">Example #1: Pub-Sub with Custom Message</a></h1>
<h2 id="aim-5"><a class="header" href="#aim-5">Aim</a></h2>
<p>To write a <code>listener</code> and <code>talker</code> node which should communicate with each other over a ROS Topic called <code>my_topic</code> using a custom ROS Message called <code>myMessage</code> with the following data fields of the following data types.</p>
<ol>
<li>int32 id</li>
<li>string name</li>
<li>float32 temperature</li>
<li>float32 humidity</li>
</ol>
<h2 id="steps-1"><a class="header" href="#steps-1">Steps</a></h2>
<h3 id="create-custom-ros-message"><a class="header" href="#create-custom-ros-message">Create Custom ROS Message</a></h3>
<ul>
<li>
<p>Messages are just simple text files with a field type and field name per line. </p>
</li>
<li>
<p>They are stored in the <code>msg</code> directory of your package. </p>
</li>
</ul>
<ol>
<li>
<p>Create a file and name it <code>myMessage.msg</code> and store it in a <code>msg</code> folder of <code>pkg_ros_basics</code>. If the folder does not exist create it.</p>
</li>
<li>
<p>Now fill the <code>myMessage.msg</code> file with the following content.</p>
<pre><code class="language-txt">int32 id
string name
float32 temperature
float32 humidity
</code></pre>
<center><a href="ROS_Basics_with_Turtlesim/ROS_Communication/ROS_Topics/./ROS_Basics_with_Turtlesim/ROS_Communication/ROS_Topics/myMessage.msg" download><button>Download</button></a></center>
<p>This is the format of a typical <code>msg</code> file.</p>
</li>
<li>
<p>Now open your <code>package.xml</code> file of <code>pkg_ros_basics</code> package and add in the dependencies for your <code>geometry_msgs</code>, <code>message_generation</code> and <code>message_runtime</code> as seen below.</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;package format=&quot;2&quot;&gt;
    &lt;name&gt;pkg_ros_basics&lt;/name&gt;
    &lt;version&gt;0.0.0&lt;/version&gt;
    &lt;description&gt;The pkg_ros_basics package&lt;/description&gt;

    &lt;maintainer email=&quot;ubuntu@todo.todo&quot;&gt;ubuntu&lt;/maintainer&gt;

    &lt;license&gt;TODO&lt;/license&gt;

    &lt;buildtool_depend&gt;catkin&lt;/buildtool_depend&gt;
    &lt;build_depend&gt;roscpp&lt;/build_depend&gt;
    &lt;build_depend&gt;rospy&lt;/build_depend&gt;
    &lt;build_depend&gt;std_msgs&lt;/build_depend&gt;
    &lt;build_export_depend&gt;roscpp&lt;/build_export_depend&gt;
    &lt;build_export_depend&gt;rospy&lt;/build_export_depend&gt;
    &lt;build_export_depend&gt;std_msgs&lt;/build_export_depend&gt;
    &lt;exec_depend&gt;roscpp&lt;/exec_depend&gt;
    &lt;exec_depend&gt;rospy&lt;/exec_depend&gt;
    &lt;exec_depend&gt;std_msgs&lt;/exec_depend&gt;
    &lt;build_depend&gt;message_generation&lt;/build_depend&gt;
    &lt;exec_depend&gt;message_runtime&lt;/exec_depend&gt;
    &lt;build_depend&gt;geometry_msgs&lt;/build_depend&gt;
    &lt;exec_depend&gt;geometry_msgs&lt;/exec_depend&gt;

    &lt;export&gt;
    &lt;/export&gt;
&lt;/package&gt;
</code></pre>
<center><a href="ROS_Basics_with_Turtlesim/ROS_Communication/ROS_Topics/./ROS_Basics_with_Turtlesim/ROS_Communication/ROS_Topics/package.xml" download><button>Download</button></a></center>
</li>
<li>
<p>Now open your <code>CMakeList.txt</code> file of <code>pkg_ros_basics</code> package and navigate to the following block of code in your file.</p>
<pre><code class="language-xml"># add_message_files(
#   FILES
#   Message1.msg
#   Message2.msg
# )
</code></pre>
<p>Uncomment the Messages and add include the name of your Message files. You can include multiple Message files if required as well.</p>
<p>Now your <code>CMakeLists.txt</code> should look like this,</p>
<pre><code class="language-txt">cmake_minimum_required(VERSION 3.0.2)
project(pkg_ros_basics)


find_package(catkin REQUIRED COMPONENTS
    roscpp
    rospy
    std_msgs
    geometry_msgs
    message_generation
)

add_message_files(
    FILES
    myMessage.msg
)

generate_messages(
    DEPENDENCIES
    std_msgs
    geometry_msgs
)

catkin_package(
#  INCLUDE_DIRS include
#  LIBRARIES pkg_ros_basics
    CATKIN_DEPENDS roscpp rospy std_msgs geometry_msgs message_runtime
#  DEPENDS system_lib
)

###########
## Build ##
###########

## Specify additional locations of header files
## Your package locations should be listed before other locations
include_directories(
# include
    ${catkin_INCLUDE_DIRS}
)
</code></pre>
<center><a href="ROS_Basics_with_Turtlesim/ROS_Communication/ROS_Topics/./ROS_Basics_with_Turtlesim/ROS_Communication/ROS_Topics/CMakeLists.txt" download><button>Download</button></a></center>
</li>
<li>
<p>After this build your package.</p>
<pre><code class="language-bash">cd ~/workspace
catkin_make
</code></pre>
<p>Once the package is build successfully you can see <code>myMessage.h</code> file located at <code>~/workspace/devel/include/pkg_ros_basics/myMessage.h</code>. This will be used by ROS Nodes to communicate over a ROS Topic using <code>myMessage</code> ROS Message. </p>
</li>
</ol>
<h2 id="code---ros-nodes"><a class="header" href="#code---ros-nodes">Code - ROS Nodes</a></h2>
<h3 id="listener-node"><a class="header" href="#listener-node">Listener Node</a></h3>
<p><code>node_myMsg_listener.py</code></p>
<pre><code class="language-python">#!/usr/bin/env python3

import rospy
from pkg_ros_basics.msg import myMessage


def func_callback_topic_my_topic(myMsg):

    rospy.loginfo(&quot;Data Received: (%d, %s, %.2f, %.2f)&quot;, myMsg.id,
                  myMsg.name, myMsg.temperature, myMsg.humidity)


def main():

    # 1. Initialize the Subscriber Node.
    rospy.init_node('node_myMsg_listener', anonymous=True)

    # 2. Subscribe to the desired topic and attach a Callback Funtion to it.
    rospy.Subscriber(&quot;my_topic&quot;, myMessage, func_callback_topic_my_topic)

    # 3. spin() simply keeps python from exiting until this node is stopped
    rospy.spin()


# Python Main
if __name__ == '__main__':
    try:
        main()
    except rospy.ROSInterruptException:
        pass
</code></pre>
<center><a href="ROS_Basics_with_Turtlesim/ROS_Communication/ROS_Topics/./ROS_Basics_with_Turtlesim/ROS_Communication/ROS_Topics/node_myMsg_listener.py" download><button>Download</button></a></center>
<h3 id="talker-node"><a class="header" href="#talker-node">Talker Node</a></h3>
<p><code>node_myMsg_talker.py</code></p>
<pre><code class="language-python">#!/usr/bin/env python3

import rospy
from pkg_ros_basics.msg import myMessage

import random


def main():
    
    # 1. Create a handle to publish messages to a topic.
    var_handle_pub = rospy.Publisher('my_topic', myMessage, queue_size=10)
    
    # 2. Initializes the ROS node for the process.
    rospy.init_node('node_myMsg_talker', anonymous=True)

    # 3. Set the Loop Rate 
    var_loop_rate = rospy.Rate(1) # 1 Hz : Loop will its best to run 1 time in 1 second
    
    # 4. Write the infinite Loop
    while not rospy.is_shutdown():
        obj_msg = myMessage()

        obj_msg.id = 1
        obj_msg.name = &quot;my_message&quot;
        obj_msg.temperature = 10 + random.random()
        obj_msg.humidity = 20 + random.random()

        rospy.loginfo(&quot;Publishing: &quot;)
        rospy.loginfo(obj_msg)

        var_handle_pub.publish(obj_msg)

        var_loop_rate.sleep()



# Python Main
if __name__ == '__main__':
    try:
        main()
    except rospy.ROSInterruptException:
        pass
</code></pre>
<center><a href="ROS_Basics_with_Turtlesim/ROS_Communication/ROS_Topics/./ROS_Basics_with_Turtlesim/ROS_Communication/ROS_Topics/node_myMsg_talker.py" download><button>Download</button></a></center>
<h2 id="output-4"><a class="header" href="#output-4">Output</a></h2>
<p>For analyzing the output for these custom messages, you can follow the following steps</p>
<ol>
<li>
<p><code>roscore</code> - As seen in previous tutorials, you must have a roscore running for the nodes to communicate. To view the messages between the talker and listener nodes, run an instance of roscore in a separate terminal window</p>
</li>
<li>
<p>listener node - For making the script of your node executable run <code>chmod +x</code> within the appropriate directory in a separate terminal window other than where your roscore is running. To run the listener node, run the following commands within your appropriate directory <code>rosrun &lt;package_name&gt; &lt;listener_node.py&gt;</code></p>
</li>
<li>
<p>talker node - You can follow the same steps mentioned above for running your talker node using the commands <code>rosrun &lt;package_name&gt; &lt;talker_node.py&gt;</code></p>
</li>
</ol>
<p>If you follow the steps given above, you should see the following output </p>
<pre><code class="language-bash">rosrun pkg_ros_basics node_myMsg_talker.py 
</code></pre>
<p><img src="ROS_Basics_with_Turtlesim/ROS_Communication/ROS_Topics/./ROS_Basics_with_Turtlesim/ROS_Communication/ROS_Topics/node-myMsg-talker.png" alt="node-myMsg-talker.png" /></p>
<br />  
```bash
rosrun pkg_ros_basics node_myMsg_listener.py
```
<p><img src="ROS_Basics_with_Turtlesim/ROS_Communication/ROS_Topics/./ROS_Basics_with_Turtlesim/ROS_Communication/ROS_Topics/node-myMsg-listener.png" alt="node-myMsg-listener.png" /></p>
<ul>
<li>If you face any problems while following this tutorial you can feel free to reach out to us. </li>
</ul>
<hr />
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="ros-services"><a class="header" href="#ros-services">ROS Services</a></h1>
<ul>
<li>
<p>The publish/subscribe model is a very flexible communication paradigm, but its many-to-many one-way transport is not appropriate for request/reply interactions, which are often required in a distributed system. </p>
</li>
<li>
<p>Request/reply is done via a Service, which is defined by a pair of messages: one for the request and one for the reply. </p>
</li>
<li>
<p>A providing ROS node offers a service under a string name, and a client calls the service by sending the request message and awaiting the reply. </p>
</li>
<li>
<p>Client libraries usually present this interaction to the programmer as if it were a remote procedure call.</p>
</li>
<li>
<p>Services are defined using <code>srv</code> files, which are compiled into source code by a ROS client library. </p>
</li>
<li>
<p>Like topics, services have an associated service type that is the package resource name of the <code>.srv</code> file.</p>
</li>
</ul>
<h2 id="reading-assignment-4"><a class="header" href="#reading-assignment-4">Reading Assignment</a></h2>
<ol>
<li><a href="http://wiki.ros.org/Services">ROS Wiki - Services</a></li>
<li><a href="https://www.cse.sc.edu/%7Ejokane/agitr/agitr-letter-service.pdf">AGITR - Services</a></li>
</ol>
<hr />
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="create-a-srv-file"><a class="header" href="#create-a-srv-file">Create a srv file</a></h1>
<h2 id="steps-2"><a class="header" href="#steps-2">Steps</a></h2>
<ol>
<li>
<p>Create a custom ROS Package or use any existing package like <code>pkg_ros_basics</code>.</p>
</li>
<li>
<p>Go into the package directory and create a folder called <code>srv</code>.</p>
<pre><code class="language-bash">roscd &lt;package_name&gt;
mkdir srv
</code></pre>
</li>
<li>
<p>Instead of creating a new srv definition by hand, we will copy an existing one from another package. For that, <code>roscp</code> is a useful commandline tool for copying files from one package to another.
Usage:</p>
<pre><code class="language-bash">roscp [package_name] [file_to_copy_path] [copy_path]
</code></pre>
<p>Now we can copy a service from the <code>rospy_tutorials</code> package:</p>
<pre><code class="language-bash">roscp rospy_tutorials AddTwoInts.srv srv/AddTwoInts.srv
</code></pre>
<p>The srv file is,</p>
<pre><code class="language-txt">int64 a
int64 b
---
int64 sum
</code></pre>
<p>Here <code>a</code> and <code>b</code> holds the request data which is sent by the Client to the Server and <code>sum</code> is the response which is sent by the Server to the Client.</p>
<center><a href="ROS_Basics_with_Turtlesim/ROS_Communication/ROS_Services/./ROS_Basics_with_Turtlesim/ROS_Communication/ROS_Services/AddTwoInts.srv" download><button>Download</button></a></center>
</li>
<li>
<p>Open <code>package.xml</code>, and make sure these two lines are in it and uncommented:</p>
<pre><code class="language-xml">&lt;build_depend&gt;message_generation&lt;/build_depend&gt;
&lt;exec_depend&gt;message_runtime&lt;/exec_depend&gt;
</code></pre>
</li>
<li>
<p>Add the <code>message_generation</code> dependency to generate messages in <code>CMakeLists.txt</code>:
<strong>Do not just add this line to your CMakeLists.txt, modify the existing line</strong></p>
<pre><code class="language-txt">find_package(catkin REQUIRED COMPONENTS
roscpp
rospy
std_msgs
message_generation
)
</code></pre>
</li>
<li>
<p>Remove <code>#</code> to uncomment the following lines:</p>
<pre><code class="language-txt"># add_service_files(
#   FILES
#   Service1.srv
#   Service2.srv
# )
</code></pre>
<p>And replace the placeholder <code>&lt;service_name&gt;.srv</code> files for your service files:</p>
<pre><code class="language-txt">add_service_files(
FILES
AddTwoInts.srv
)
</code></pre>
</li>
<li>
<p>Unless you have already done this in the previous steps, change in <code>CMakeLists.txt</code>. :</p>
<pre><code class="language-txt"># generate_messages(
#   DEPENDENCIES
# #  std_msgs  # Or other packages containing msgs
# )
</code></pre>
<p>Uncomment it and add any packages you depend on which contain <code>.msg</code> files that your messages use (in this case std_msgs), such that it looks like this:</p>
<pre><code class="language-txt">generate_messages(
DEPENDENCIES
std_msgs
)
</code></pre>
</li>
</ol>
<center><a href="ROS_Basics_with_Turtlesim/ROS_Communication/ROS_Services/./ROS_Basics_with_Turtlesim/ROS_Communication/ROS_Services/CMakeLists.txt" download><button>Download CMakeLists.txt</button></a></center>
<ol>
<li>Go to <code>workspace</code> directory and run:
<pre><code class="language-bash">catkin_make
</code></pre>
</li>
</ol>
<h2 id="rossrv-command"><a class="header" href="#rossrv-command">rossrv Command</a></h2>
<p>The <code>rossrv</code> command-line tool displays information about ROS services. It has the exact same usage as <code>rosmsg</code> (see what it offers when it runs without sub-command below):</p>
<pre><code class="language-bash">rossrv -h
rossrv show pkg_ros_basics/AddTwoInts
</code></pre>
<h2 id="img-srcros_basics_with_turtlesimros_communicationros_servicesros_basics_with_turtlesimros_communicationros_servicesrossrv-commandpng-altrossrv-commandpng-"><a class="header" href="#img-srcros_basics_with_turtlesimros_communicationros_servicesros_basics_with_turtlesimros_communicationros_servicesrossrv-commandpng-altrossrv-commandpng-"><img src="ROS_Basics_with_Turtlesim/ROS_Communication/ROS_Services/./ROS_Basics_with_Turtlesim/ROS_Communication/ROS_Services/rossrv-command.png" alt="rossrv-command.png" /></a></h2>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="test-ros-services---server-and-client"><a class="header" href="#test-ros-services---server-and-client">Test ROS Services - Server and Client</a></h1>
<blockquote>
<p>For in depth code details in python language <a href="http://wiki.ros.org/ROS/Tutorials/WritingServiceClient%28python%29">Click here</a></p>
</blockquote>
<blockquote>
<p>For in depth code details in Cpp language <a href="http://wiki.ros.org/ROS/Tutorials/WritingServiceClient%28c%2B%2B%29">Click here</a></p>
</blockquote>
<ul>
<li>We will use an example from <code>rospy_tutorials</code>.</li>
</ul>
<h2 id="steps-3"><a class="header" href="#steps-3">Steps</a></h2>
<ol>
<li>
<p>First, run <code>roscore</code> command in a new terminal.</p>
<pre><code class="language-bash">roscore
</code></pre>
</li>
<li>
<p>Then run this command in a new terminal:</p>
<pre><code class="language-bash">rosrun rospy_tutorials add_two_ints_server 
</code></pre>
</li>
<li>
<p>Run this command in the new terminal for adding integer 12 and integer 20:</p>
<pre><code class="language-bash">rosrun rospy_tutorials add_two_ints_client 12 20
</code></pre>
</li>
</ol>
<h2 id="output-5"><a class="header" href="#output-5">Output</a></h2>
<pre><code class="language-bash">rosrun rospy_tutorials add_two_ints_server
</code></pre>
<pre><code class="language-bash">Returning [12 + 20 = 32]
Returning [12 + 20 = 32]
</code></pre>
<br />
<pre><code class="language-bash">rosrun rospy_tutorials add_two_ints_client 12 20
</code></pre>
<pre><code class="language-bash">Requesting 12+20
12 + 20 = 32
</code></pre>
<hr />
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="ros-actions"><a class="header" href="#ros-actions">ROS Actions</a></h1>
<ul>
<li>In any large ROS based system, here are cases when someone would like to send a request to a node to perform some task, and also receive a reply to the request. This can currently be achieved via <code>ROS services</code>. </li>
<li>However, in some cases the sevices takes a long time to execute.</li>
<li>The user might want the ability to cancel the request during execution or get periodic feedback about how the request is progressing.</li>
<li>The <code>actionlib</code> package provides tools to create servers that execute long-running goals that can be preempted</li>
<li>It also provides a client interface in order to send requests to the server.</li>
<li>The action specification is defined using a <code>.action</code> file. The <code>.action</code> file has the goal definition, followed by the result definition, followed by the feedback definition, with each section separated by 3 hyphens (---). </li>
</ul>
<h2 id="reference-2"><a class="header" href="#reference-2">Reference</a></h2>
<ul>
<li>More details about how actionlib operates &quot;under the hood&quot; are <a href="http://wiki.ros.org/actionlib/DetailedDescription">here</a></li>
</ul>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="create-an-action-message-file"><a class="header" href="#create-an-action-message-file">Create an action message file</a></h1>
<p>Before writing an action it is important to define the goal, result, and feedback messages. The action messages are generated automatically from the <code>.action</code> file, for more information on action files see the <a href="https://wiki.ros.org/actionlib">actionlib</a> documentation. This file defines the type and format of the goal, result, and feedback topics for the action. Create actionlib_tutorials/action/Fibonacci.action in your favorite editor, and place the following inside it:</p>
<pre><code>#goal definition
int32 order
---
#result definition
int32[] sequence
---
#feedback
int32[] sequence
</code></pre>
<p>To automatically generate the message files during the make process, a few things need to be added to CMakeLists.txt.</p>
<ul>
<li>
<p>add the actionlib_msgs package to the find_package macro's argument like this (if you used catkin_create_package to generate CMakeLists.txt, this may already have been added):</p>
<pre><code>find_package(catkin REQUIRED COMPONENTS actionlib_msgs)
</code></pre>
<ul>
<li>
<p>Note that CMake needs to find_package actionlib_msgs (message_generation does not need to be listed explicitly, it is referenced implicitly by actionlib_msgs). </p>
</li>
<li>
<p>use the add_action_files macro to declare the actions you want to be generated:</p>
</li>
</ul>
<pre><code>add_action_files(
DIRECTORY action
FILES Fibonacci.action
)
</code></pre>
</li>
<li>
<p>call the generate_messages macro, not forgetting the dependencies on actionlib_msgs and other message packages like std_msgs: </p>
<pre><code>generate_messages(
DEPENDENCIES actionlib_msgs std_msgs  # Or other packages containing msgs
)    
</code></pre>
</li>
<li>
<p>add actionlib_msgs to catkin_package macro like this:</p>
<pre><code>catkin_package(
CATKIN_DEPENDS actionlib_msgs
)
</code></pre>
<ul>
<li>catkin_package also specifies only CATKIN_DEPEND to actionlib_msgs. The transitive dependency on message_runtime is happening automatically. </li>
</ul>
</li>
</ul>
<p>Note: Sometimes you have to setup your package.xml, since we are generating messages you have to declare on the manifest file that at run time you have to generate messages. You could just insert the follow line.</p>
<pre><code>&lt;exec_depend&gt;message_generation&lt;/exec_depend&gt;

</code></pre>
<p>Now by following, automatically generate msg files of your action files, and also see the result. </p>
<pre><code class="language-bash">$ cd ../.. # Go back to the top level of your catkin workspace
$ catkin_make
$ ls devel/share/actionlib_tutorials/msg/
FibonacciActionFeedback.msg  FibonacciAction.msg        FibonacciFeedback.msg
FibonacciResult.msg          FibonacciActionGoal.msg    FibonacciActionResult.msg  FibonacciGoal.msg
$ ls devel/include/actionlib_tutorials/
FibonacciActionFeedback.h  FibonacciAction.h        FibonacciFeedback.h  FibonacciResult.h
FibonacciActionGoal.h      FibonacciActionResult.h  FibonacciGoal.h
</code></pre>
<p>To manually generate the message files from this file, use the script genaction.py from the actionlib_msgs package. </p>
<h3 id="reference-3"><a class="header" href="#reference-3">Reference</a></h3>
<ul>
<li><a href="https://wiki.ros.org/actionlib_tutorials/Tutorials/SimpleActionServer(ExecuteCallbackMethod)#actionlib_tutorials.2BAC8-Tutorials.2BAC8-SimpleActionServer.28ExecuteCallbackMethod.29.2BAC8-groovy.Creating_the_Action_Messages">actionlib_tutorial</a></li>
</ul>
<hr><div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="simple-action-server--client"><a class="header" href="#simple-action-server--client">Simple Action Server &amp; Client</a></h1>
<ul>
<li>This tutorial covers using the simple_action_server library to create a Fibonacci action server in Python. This example action server generates a Fibonacci sequence, the goal is the order of the sequence, the feedback is the sequence as it is computed, and the result is the final sequence.</li>
</ul>
<h2 id="writing-a-simple-server"><a class="header" href="#writing-a-simple-server">Writing a Simple Server</a></h2>
<ul>
<li>The following code can be found in actionlib_tutorials/simple_action_servers/fibonacci_server.py, and implements a python action server for the <a href="http://docs.ros.org/api/actionlib_tutorials/html/classfibonacci__server_1_1FibonacciAction.html">fibonacci action</a>.</li>
</ul>
<pre><code class="language-python">#! /usr/bin/env python
 
 import rospy
 
 import actionlib
 
 import actionlib_tutorials.msg
 
 class FibonacciAction(object):
     # create messages that are used to publish feedback/result
     _feedback = actionlib_tutorials.msg.FibonacciFeedback()
     _result = actionlib_tutorials.msg.FibonacciResult()
 
     def __init__(self, name):
         self._action_name = name
         self._as = actionlib.SimpleActionServer(self._action_name, actionlib_tutorials.msg.FibonacciAction, execute_cb=self.execute_cb, auto_start = False)
         self._as.start()
       
     def execute_cb(self, goal):
         # helper variables
         r = rospy.Rate(1)
         success = True
         
         # append the seeds for the fibonacci sequence
         self._feedback.sequence = []
         self._feedback.sequence.append(0)
         self._feedback.sequence.append(1)
         
         # publish info to the console for the user
         rospy.loginfo('%s: Executing, creating fibonacci sequence of order %i with seeds %i, %i' % (self._action_name, goal.order, self._feedback.sequence[0], self._feedback.sequence[1]))
        
         # start executing the action
         for i in range(1, goal.order):
             # check that preempt has not been requested by the client
             if self._as.is_preempt_requested():
                 rospy.loginfo('%s: Preempted' % self._action_name)
                 self._as.set_preempted()
                 success = False
                 break
             self._feedback.sequence.append(self._feedback.sequence[i] + self._feedback.sequence[i-1])
             # publish the feedback
             self._as.publish_feedback(self._feedback)
             # this step is not necessary, the sequence is computed at 1 Hz for demonstration purposes
             r.sleep()
          
         if success:
             self._result.sequence = self._feedback.sequence
             rospy.loginfo('%s: Succeeded' % self._action_name)
             self._as.set_succeeded(self._result)
         
 if __name__ == '__main__':
     rospy.init_node('fibonacci')
     server = FibonacciAction(rospy.get_name())
     rospy.spin()

</code></pre>
<p>You can see more about this code <a href="http://wiki.ros.org/actionlib_tutorials/Tutorials/Writing%20a%20Simple%20Action%20Server%20using%20the%20Execute%20Callback%20%28Python%29">here</a>.</p>
<h2 id="compiling"><a class="header" href="#compiling">Compiling</a></h2>
<p>Only initially when you just created your tutorial package, you need to compile to generate shell config files.</p>
<pre><code class="language-bash">cd %TOPDIR_YOUR_CATKIN_WORKSPACE%
catkin_make
source devel/setup.bash
</code></pre>
<h2 id="running-the-action-server"><a class="header" href="#running-the-action-server">Running the Action Server</a></h2>
<p>Run: </p>
<pre><code class="language-bash">roscore
</code></pre>
<p>Then on a new terminal, the following command will run the action server.</p>
<pre><code class="language-bash">rosrun actionlib_tutorials fibonacci_server.py
</code></pre>
<h2 id="writing-a-simple-action-client"><a class="header" href="#writing-a-simple-action-client">Writing a Simple Action Client</a></h2>
<p>The following code can be found in <a href="http://wiki.ros.org/actionlib_tutorials">actionlib_tutorials</a> repository, and implements a simple python action client for the <a href="http://docs.ros.org/api/actionlib_tutorials/html/classfibonacci__server_1_1FibonacciAction.html">fibonacci action</a>.</p>
<pre><code class="language-python">#! /usr/bin/env python
 
 import rospy
 from __future__ import print_function
 
 # Brings in the SimpleActionClient
 import actionlib
 
 # Brings in the messages used by the fibonacci action, including the
 # goal message and the result message.
 import actionlib_tutorials.msg
 
 def fibonacci_client():
     # Creates the SimpleActionClient, passing the type of the action
     # (FibonacciAction) to the constructor.
     client = actionlib.SimpleActionClient('fibonacci', actionlib_tutorials.msg.FibonacciAction)
 
     # Waits until the action server has started up and started
     # listening for goals.
     client.wait_for_server()
 

     # Creates a goal to send to the action server.
     goal = actionlib_tutorials.msg.FibonacciGoal(order=20)
 
     # Sends the goal to the action server.
     client.send_goal(goal)
 
     # Waits for the server to finish performing the action.
     client.wait_for_result()
 
     # Prints out the result of executing the action
     return client.get_result()  # A FibonacciResult
 
 if __name__ == '__main__':
     try:
         # Initializes a rospy node so that the SimpleActionClient can
         # publish and subscribe over ROS.
         rospy.init_node('fibonacci_client_py')
         result = fibonacci_client()
         print(&quot;Result:&quot;, ', '.join([str(n) for n in result.sequence]))
     except rospy.ROSInterruptException:
         print(&quot;program interrupted before completion&quot;, file=sys.stderr)

</code></pre>
<p>You can read more about the code <a href="http://wiki.ros.org/actionlib_tutorials/Tutorials/Writing%20a%20Simple%20Action%20Client%20%28Python%29">here</a>.</p>
<h2 id="running-the-client"><a class="header" href="#running-the-client">Running the client</a></h2>
<p>Before running the client, we assume roscore ans Action server are already running from previous page.</p>
<p>Start the client. It will start up, send a goal to the server, wait for the goal to complete, and then exit.</p>
<pre><code class="language-bash">rosrun actionlib_tutorials fibonacci_client.py
</code></pre>
<h3 id="reference-4"><a class="header" href="#reference-4">Reference</a></h3>
<ul>
<li><a href="http://wiki.ros.org/actionlib/Tutorials">ROS Wiki</a>.</li>
</ul>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="action-server--client"><a class="header" href="#action-server--client">Action Server &amp; Client</a></h1>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="ros-actions-walkthrough-videos"><a class="header" href="#ros-actions-walkthrough-videos">ROS Actions Walkthrough Videos</a></h1>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="ros-tf"><a class="header" href="#ros-tf">ROS TF</a></h1>
<ul>
<li><code>tf</code> is a package that lets the user keep track of multiple coordinate frames over time.</li>
<li><code>tf</code> maintains the relationship between coordinate frames in a tree structure buffered in time, and lets the user transform points, vectors, etc between any two coordinate frames at any desired point in time.</li>
<li>A robotic system typically has many 3D <a href="http://wiki.ros.org/geometry/CoordinateFrameConventions">coordinate frames</a> that change over time, such as a world frame, base frame, gripper frame, head frame, etc.</li>
<li>tf keeps track of all these frames over time, and allows you to ask questions like:
<ul>
<li>Where was the head frame relative to the world frame, 5 seconds ago?</li>
<li>What is the pose of the object in my gripper relative to my base?</li>
<li>What is the current pose of the base frame in the map frame?</li>
</ul>
</li>
<li>tf can operate in a <code>distributed system</code>. This means all the information about the coordinate frames of a robot is available to all ROS components on any computer in the system. There is <code>no central server</code> of transform information.</li>
</ul>
<h2 id="reference-5"><a class="header" href="#reference-5">Reference</a></h2>
<ul>
<li><a href="http://wiki.ros.org/tf">ROS-wiki</a></li>
</ul>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="ros-tf-using-turtlesim"><a class="header" href="#ros-tf-using-turtlesim">ROS tf using turtlesim:</a></h1>
<p>This tutorial will give you a good idea of what tf can do for you. It shows off some of the tf power in a multi-robot example using <a href="http://wiki.ros.org/turtlesim">turtlesim</a>. This also introduces using <a href="http://wiki.ros.org/tf#tf_echo">tf_echo</a>, <a href="http://wiki.ros.org/tf#view_frames">view_frames</a>, <a href="http://wiki.ros.org/rqt_tf_tree">rqt_tf_tree</a>, and <a href="http://wiki.ros.org/rviz">rviz</a>.</p>
<h2 id="1-set-up-the-demo"><a class="header" href="#1-set-up-the-demo">1. Set Up the Demo</a></h2>
<p>The nodes for this tutorial are released for Ubuntu, so go ahead and install them: </p>
<pre><code class="language-bash">$ sudo apt-get install ros-noetic-ros-tutorials ros-noetic-geometry-tutorials ros-noetic-rviz ros-noetic-rosbash ros-noetic-rqt-tf-tree

</code></pre>
<h2 id="2-running-the-demo"><a class="header" href="#2-running-the-demo">2. Running the Demo</a></h2>
<p>Now that we're done getting the turtle_tf tutorial package, let's run the demo. </p>
<pre><code class="language-bash">$ roslaunch turtle_tf turtle_tf_demo.launch
</code></pre>
<p>You will see the turtlesim start with two turtles. </p>
<p><img src="ROS_Basics_with_Turtlesim/ROS_TF/turtle_tf_start.png" alt="image" /></p>
<p>Once the turtlesim is started you can drive the center turtle around in the turtlesim using the keyboard arrow keys, select the <strong>roslaunch terminal window</strong> so that your keystrokes will be captured to drive the turtle.</p>
<p><img src="ROS_Basics_with_Turtlesim/ROS_TF/turtle_tf_drive.png" alt="image" /></p>
<p>As you can see that one turtle will continuously move to follow the turtle you are driving around. </p>
<h2 id="3-what-is-happening"><a class="header" href="#3-what-is-happening">3. What is Happening</a></h2>
<p>This demo is using the tf library to create three coordinate frames: a world frame, a turtle1 frame, and a turtle2 frame. This tutorial uses a <strong>tf broadcaster</strong> to publish the turtle coordinate frames and a <strong>tf listener</strong> to compute the difference in the turtle frames and move one turtle to follow the other. </p>
<h3 id="reference-6"><a class="header" href="#reference-6">Reference</a></h3>
<ul>
<li><a href="http://wiki.ros.org/tf/Tutorials/Introduction%20to%20tf">ros_tf_tutorial</a></li>
</ul>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="miscellaneous"><a class="header" href="#miscellaneous">Miscellaneous</a></h1>
<blockquote>In this section we will discuss some miscellaneous topics which a basic ROS user should know about.</blockquote>
<hr><div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="rqt_graph"><a class="header" href="#rqt_graph">Rqt_graph</a></h1>
<h2 id="ros-gui-development-tool-rqt"><a class="header" href="#ros-gui-development-tool-rqt">ROS GUI Development Tool (rqt)</a></h2>
<ul>
<li>
<p>ROS provides various GUI tools for robot development.</p>
</li>
<li>
<p>These tools helps to visualize and analyze your ROS Application.</p>
</li>
<li>
<p>Following are some rqt tools provided by ROS.</p>
<ul>
<li>rqt plugins</li>
<li>rqt_image_view</li>
<li>rqt_graph</li>
<li>rqt_plot</li>
<li>rqt_bag</li>
</ul>
</li>
<li>
<p><code>rqt_graph</code> is a tool used to your entire ROS Network as a diagram.</p>
</li>
<li>
<p>This is a very handy tool if you want to visualize how ROS Nodes are communicating with each other and how they are connected to each other.</p>
</li>
</ul>
<h2 id="usage"><a class="header" href="#usage">Usage</a></h2>
<p>In this secion, we will see few inspection commands that are used to find information about ROS Nodes and ROS Topics running as a part of a ROS application.</p>
<p>First and foremost, open a new terminal and type roscore command to start your ROS Master node.</p>
<pre><code class="language-bash">$ roscore
</code></pre>
<p>Now the result of this command will resemble he output discussed in previous module. For this module we will be using turtlesim simulator that is part of ROS installation.</p>
<p>Run following command in a new terminal window.</p>
<pre><code class="language-bash">$ rosrun turtlesim turtlesim_node
</code></pre>
<p>You will see output similar to this:</p>
<pre><code class="language-bash">[ INFO] [1601303390.799401514]: Starting turtlesim with node name /turtlesim
[ INFO] [1601303390.804994858]: Spawning turtle [turtle1] at x=[5.544445], y=[5.544445], theta=[0.000000]
</code></pre>
<p>You will also see image of a turtle at the center in the display screen, as shown in the output below. The turtle in the window is called as turtle1 because it is the first and only turtle in our display.</p>
<p><img src="ROS_Basics_with_Turtlesim/Miscellaneous/turtle.png" alt="image" /></p>
<p>So there will be two terminal windows active which can be minimized or dragged off to the side or bottom but should not be closed. We will use three commands that will help us find our way around.</p>
<p>The first command is, &quot;rosnode list&quot;. This command prints a list of all running nodes on the terminal.</p>
<p>In third terminal, run the following command:</p>
<pre><code class="language-bash">$ rosnode list
</code></pre>
<p>You will see output similar to this:</p>
<pre><code class="language-bash">/rosout
/turtlesim
</code></pre>
<p>The next command &quot;rosnode info &quot;. This command prints node specific information on the terminal.</p>
<pre><code class="language-bash">$ rosnode info /turtlesim
</code></pre>
<p>You will see output similar to this:</p>
<pre><code class="language-bash">Node [/turtlesim]
Publications: 
 * /rosout [rosgraph_msgs/Log]
 * /turtle1/color_sensor [turtlesim/Color]
 * /turtle1/pose [turtlesim/Pose]

Subscriptions: 
 * /turtle1/cmd_vel [unknown type]

Services: 
 * /clear
 * /kill
 * /reset
 * /spawn
 * /turtle1/set_pen
 * /turtle1/teleport_absolute
 * /turtle1/teleport_relative
 * /turtlesim/get_loggers
 * /turtlesim/set_logger_level


 contacting node http://ruchi24-Vostro-15-3568:42299/ ...
 Pid: 12698
 Connections:
  * topic: /rosout
     * to: /rosout
     * direction: outbound (57779 - 127.0.0.1:51260) [24]
     * transport: TCPROS
</code></pre>
<p>And finally, the command &quot;rqt_graph&quot;. This command provides a visual representation of the different nodes and the way they interact with each other. We can see the structure of how topics are passed around the system using rqt_graph.</p>
<p>rqt_graph is part of the rqt package. Unless you already have it installed, run:</p>
<pre><code class="language-bash">$ sudo apt-get install ros-melodic-rqt
$ sudo apt-get install ros-melodic-rqt-common-plugins
</code></pre>
<p>We'll need something to drive the turtle aroud with. Open a new terminal window and run following command:</p>
<pre><code class="language-bash">$ rosrun turtlesim turtle_teleop_key
</code></pre>
<p>You will see output similar to this:</p>
<pre><code class="language-bash">Reading from keyboard
---------------------------
Use arrow keys to move the turtle. 'q' to quit.
</code></pre>
<p>You can use arrow keys from the keyboard to drive the turtle around. Now that you can drive your turtle around, let's see what's going on behind the scenes.</p>
<p>Basically the turtlesim_node and turtle_teleop_key are communicating with each other over a ROS Topic. turtle_teleop_key is publishing the key strokes on a topic, while turtlesim subscribes to the same topic to receive the key strokes.</p>
<p>Open a new terminal window and run following command:</p>
<pre><code class="language-bash">$ rosrun rqt_graph rqt_graph
</code></pre>
<p>You will see output similar to this:</p>
<p><img src="ROS_Basics_with_Turtlesim/Miscellaneous/rqt_graph1.png" alt="image" /></p>
<p>If you place your mouse over /turtle1/command_velocity it will highlight the ROS nodes (here blue and green) and topics (here red). As you can see, the turtlesim_node and the turtle_teleop_key nodes are communicating on the topic named /turtle1/command_velocity. </p>
<p><img src="ROS_Basics_with_Turtlesim/Miscellaneous/rqt_graph.png" alt="image" /></p>
<hr>
<h3 id="reference-7"><a class="header" href="#reference-7">Reference</a></h3>
<ol>
<li><a href="http://wiki.ros.org/ROS/Tutorials/UnderstandingTopics#Using_rqt_graph">ROS Wiki - rqt_graph</a></li>
</ol>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="plot-juggler"><a class="header" href="#plot-juggler">Plot Juggler</a></h1>
<ul>
<li>PlotJuggler is an application to plot logged data, in particular timeseries.</li>
<li>It helps to visualize time series that is fast, powerful and intuitive.</li>
</ul>
<h2 id="installation"><a class="header" href="#installation">Installation</a></h2>
<p><strong>For ROS users, to install PlotJuggler just type:</strong></p>
<pre><code class="language-bash">sudo apt install ros-${ROS_DISTRO}-plotjuggler-ros
</code></pre>
<p>which for ROS-noetic will be:</p>
<pre><code class="language-bash">sudo apt install ros-noetic-plotjuggler-ros
</code></pre>
<p>To launch PlotJuggler on ROS, use the comand:</p>
<pre><code class="language-bash">rosrun plotjuggler plotjuggler
</code></pre>
<p>or, if are using ROS2:</p>
<pre><code class="language-bash">ros2 run plotjuggler plotjuggler

</code></pre>
<p>for more details vist <a href="https://github.com/facontidavide/PlotJuggler/blob/main/README.md">here</a></p>
<h2 id="visualizing-streamed-data"><a class="header" href="#visualizing-streamed-data">Visualizing Streamed Data</a></h2>
<p>PlotJuggler is most commonly used to visualize data that is stored in a log file, for instance a <a href="https://en.wikipedia.org/wiki/Comma-separated_values">CSV</a> or a <a href="http://wiki.ros.org/rosbag">rosbag</a>. This kind of data is usually loaded using plugins named &quot;DataLoader&quot;.</p>
<p>Additionally, it is possible to visualize data that is being streamed. The user can easily start and stope streaming and decide the size of the buffer (in seconds).</p>
<p>Note that some functionalities such as zoom, pan and the time tracker are disabled when streaming is ON.</p>
<p>Lets try it on the turtlesim tutorial.</p>
<p>Open the terminal and run roscore.</p>
<pre><code class="language-bash">roscore
</code></pre>
<p>in second terminal run:</p>
<pre><code class="language-bash">rosrun turtlesim turtlesim_node
</code></pre>
<p>This window will open:
<img src="ROS_Basics_with_Turtlesim/Miscellaneous/turtle.png" alt="image" /></p>
<p>In third terminal run command:</p>
<pre><code class="language-bash">rostopic pub -r 1 /turtle1/cmd_vel geometry_msgs/Twist -- '[2.0, 0.0, 0.0]' '[0.0, 0.0, 1.8]'
</code></pre>
<p>this will make the turtle move in a circle.
<img src="ROS_Basics_with_Turtlesim/Miscellaneous/revolve.png" alt="image" /></p>
<p>In the fourth terminal run PlotJuggler.</p>
<pre><code class="language-bash">rosrun plotjuggler plotjuggler
</code></pre>
<p>This window will open:
<img src="ROS_Basics_with_Turtlesim/Miscellaneous/PlotJuggler.png" alt="image" /></p>
<p>Under the Streaming tab select ROS Topic Subscriber
and then click on start.</p>
<p>A new window will open.
<img src="ROS_Basics_with_Turtlesim/Miscellaneous/select_ros.png" alt="image" /></p>
<p>Select the Ros topic u want for now select /turtle1/pose.</p>
<p>Now turtle1 ros topic will be available inthe timeseries. U can drag and drop individual data or messages that u want to plot.</p>
<p>Select turtle1/pose/x and turtle1/pose/y.</p>
<p>The selected Data will be plotted.
<img src="ROS_Basics_with_Turtlesim/Miscellaneous/plot.png" alt="image" /></p>
<h3 id="reference-8"><a class="header" href="#reference-8">Reference</a></h3>
<ul>
<li><a href="https://facontidavide.github.io/PlotJuggler/data_sources/index.html">PlotJuggler</a></li>
</ul>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="ros-bags"><a class="header" href="#ros-bags">ROS Bags</a></h1>
<p>A bag is a file format in ROS for storing ROS <a href="http://wiki.ros.org/Messages">message</a> data. Bags -- so named because of their .bag extension -- have an important role in ROS, and a variety of tools have been written to allow you to store, process, analyze, and visualize them.</p>
<p>U can read more about them <a href="http://wiki.ros.org/Bags">here</a>.</p>
<h2 id="recording-and-playing-back-data"><a class="header" href="#recording-and-playing-back-data">Recording and playing back data</a></h2>
<p>In this section we will learn how to record data from a running ROS system into a .bag file, and then to play back the data to produce similar behavior in a running system</p>
<p>First, execute the following commands in separate terminals:</p>
<p>Terminal 1:</p>
<pre><code class="language-bash">roscore
</code></pre>
<p>Terminal 2:</p>
<pre><code class="language-bash">rosrun turtlesim turtlesim_node
</code></pre>
<p>Terminal 3:</p>
<pre><code class="language-bash">rosrun turtlesim turtle_teleop_key
</code></pre>
<p>This will start two nodes - the turtlesim visualizer and a node that allows for the keyboard control of turtlesim using the arrows keys on the keyboard. If you select the terminal window from which you launched turtle_keyboard, you should see something like the following:</p>
<pre><code class="language-bash">Reading from keyboard
---------------------------
Use arrow keys to move the turtle.
</code></pre>
<p>Pressing the arrow keys on the keyboard should cause the turtle to move around the screen. Note that to move the turtle you must have the terminal from which you launched turtlesim selected and not the turtlesim window. </p>
<p>We now will record the published data. Open a new terminal window. In this window run the following commands:</p>
<pre><code class="language-bash">mkdir ~/bagfiles
cd ~/bagfiles
rosbag record -a
</code></pre>
<p>Here we are just making a temporary directory to record data and then running rosbag record with the option -a, indicating that all published topics should be accumulated in a bag file. </p>
<p>Move back to the terminal window with turtle_teleop and move the turtle around for 10 or so seconds.</p>
<p>In the window running rosbag record exit with a Ctrl-C. Now examine the contents of the directory ~/bagfiles. You should see a file with a name that begins with the year, date, and time and the suffix .bag. This is the bag file that contains all topics published by any node in the time that rosbag record was running. </p>
<p>Now that we've recorded a bag file using rosbag record we can examine it and play it back using the commands rosbag info and rosbag play. First we are going to see what's recorded in the bag file. We can do the info command -- this command checks the contents of the bag file without playing it back. Execute the following command from the bagfiles directory: </p>
<pre><code class="language-bash">rosbag info &lt;your bagfile&gt;
</code></pre>
<p>You should see something like:</p>
<pre><code class="language-bash">path:        2014-12-10-20-08-34.bag
version:     2.0
duration:    1:38s (98s)
start:       Dec 10 2014 20:08:35.83 (1418270915.83)
end:         Dec 10 2014 20:10:14.38 (1418271014.38)
size:        865.0 KB
messages:    12471
compression: none [1/1 chunks]
types:       geometry_msgs/Twist [9f195f881246fdfa2798d1d3eebca84a]
             rosgraph_msgs/Log   [acffd30cd6b6de30f120938c17c593fb]
             turtlesim/Color     [353891e354491c51aabe32df673fb446]
             turtlesim/Pose      [863b248d5016ca62ea2e895ae5265cf9]
topics:      /rosout                    4 msgs    : rosgraph_msgs/Log   (2 connections)
             /turtle1/cmd_vel         169 msgs    : geometry_msgs/Twist
             /turtle1/color_sensor   6149 msgs    : turtlesim/Color
             /turtle1/pose           6149 msgs    : turtlesim/Pose
</code></pre>
<p>This tells us topic names and types as well as the number (count) of each message topic contained in the bag file. We can see that of the topics being advertised that we saw in the rostopic output, four of the five were actually published over our recording interval. As we ran rosbag record with the -a flag it recorded all messages published by all nodes. </p>
<p>Lets play the bag file to reproduce behavior in the running system. First kill the teleop program that may be still running from the previous section - a Ctrl-C in the terminal where you started turtle_teleop_key. Leave turtlesim running. In a terminal window run the following command in the directory where you took the original bag file:</p>
<pre><code class="language-bash">rosbag play &lt;your bagfile&gt;
</code></pre>
<p>In this window you should immediately see something like:</p>
<pre><code class="language-bash">[ INFO] [1418271315.162885976]: Opening 2014-12-10-20-08-34.bag

Waiting 0.2 seconds after advertising topics... done.

Hit space to toggle paused, or 's' to step.
</code></pre>
<p>Eventually the topic /turtle1/cmd_vel will be published and the turtle should start moving in turtlesim in a pattern similar to the one you executed from the teleop program. The duration between running rosbag play and the turtle moving should be approximately equal to the time between the original rosbag record execution and issuing the commands from the keyboard in the beginning part of the tutorial. You can have rosbag play not start at the beginning of the bag file but instead start some duration past the beginning using the -s argument. A final option that may be of interest is the -r option, which allows you to change the rate of publishing by a specified factor. If you execute:</p>
<pre><code class="language-bash">rosbag play -r 2 &lt;your bagfile&gt;
</code></pre>
<p>You should see the turtle execute a slightly different trajectory - this is the trajectory that would have resulted had you issued your keyboard commands twice as fast. </p>
<h3 id="reference-9"><a class="header" href="#reference-9">Reference</a></h3>
<ul>
<li><a href="http://wiki.ros.org/ROS/Tutorials/Recording%20and%20playing%20back%20data">rosbag tutorial</a></li>
</ul>
<hr><div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="additional-sections"><a class="header" href="#additional-sections">Additional Sections</a></h1>
<ul>
<li>This section will make user get used to terminal and also ros basic commands.</li>
<li>It will also help them later if they've to do debugging.</li>
<li>It is practice purpose only.</li>
</ul>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="configuring-your-ros-environment"><a class="header" href="#configuring-your-ros-environment">Configuring your ROS environment</a></h1>
<p><strong>Goal</strong>: This tutorial will show you how to prepare your ROS environment.</p>
<h2 id="prerequisites"><a class="header" href="#prerequisites">Prerequisites</a></h2>
<p>Before starting these tutorials please complete installation as described in the <a href="http://wiki.ros.org/ROS/Installation">ROS installation instructions</a>.</p>
<h2 id="managing-your-environment"><a class="header" href="#managing-your-environment">Managing Your Environment</a></h2>
<p>During the installation of ROS, you will see that you are prompted to source one of several setup.*sh files, or even add this 'sourcing' to your shell startup script. This is required because ROS relies on the notion of combining spaces using the shell environment. This makes developing against different versions of ROS or against different sets of packages easier.</p>
<p>If you are ever having problems finding or using your ROS packages make sure that you have your environment properly setup. A good way to check is to ensure that environment variables like ROS_ROOT and ROS_PACKAGE_PATH are set: </p>
<pre><code class="language-bash">$ printenv | grep ROS
</code></pre>
<pre><code class="language-bash">ROS_VERSION=1
ROS_PYTHON_VERSION=3
ROS_PACKAGE_PATH=/home/ubuntu/workspace/src:/opt/ros/noetic/share
ROSLISP_PACKAGE_DIRECTORIES=/home/ubuntu/workspace/devel/share/common-lisp
ROS_ETC_DIR=/opt/ros/noetic/etc/ros
ROS_MASTER_URI=http://localhost:11311
ROS_ROOT=/opt/ros/noetic/share/ros
ROS_DISTRO=noetic
</code></pre>
<p>If they are not then you might need to 'source' some setup.*sh files. </p>
<pre><code class="language-bash">$ source /opt/ros/noetic/setup.bash
</code></pre>
<blockquote>
<p><strong>NOTE</strong>: You will need to run this command on every new shell you open to have access to the ROS commands, unless you add this line to your .bashrc.</p>
</blockquote>
<p>To add this line to .bashrc run this command:</p>
<pre><code class="language-bash">echo &quot;source /opt/ros/noetic/setup.bash&quot; &gt;&gt; ~/.bashrc
</code></pre>
<p>To undo this (to change to another distro) in Linux and macOS, locate your system’s shell startup script and remove the appended source command.</p>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<p>The ROS development environment needs to be correctly configured before use. This can be done in two ways: either sourcing the setup files in every new shell you open, or adding the source command to your startup script.</p>
<p>If you ever face any problems locating or using packages with ROS, the first thing you should do is check your environment variables and ensure they are set to the version and distro you intended.</p>
<hr />
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="introducing-turtlesim-and-rqt"><a class="header" href="#introducing-turtlesim-and-rqt">Introducing turtlesim and rqt</a></h1>
<p><strong>Goal</strong>: Install and use the turtlesim package and rqt tools to prepare for upcoming tutorials.</p>
<h2 id="background"><a class="header" href="#background">Background</a></h2>
<p>Turtlesim is a lightweight simulator for learning ROS. It illustrates what ROS does at the most basic level, to give you an idea of what you will do with a real robot or robot simulation later on.</p>
<p>rqt is a GUI tool for ROS. Everything done in rqt can be done on the command line, but it provides an easier, more user-friendly way to manipulate ROS elements.</p>
<p>This tutorial touches on core ROS concepts, like the separation of nodes, topics, and services. All of these concepts will be elaborated on in later tutorials; for now, you will simply set up the tools and get a feel for them.</p>
<h2 id="prerequisites-1"><a class="header" href="#prerequisites-1">Prerequisites</a></h2>
<p>The previous tutorial, <a href="Additional_Sections/./Additional_Sections/configuring_your_ros_environment.html">Configuring your ROS environment</a>, will show you how to set up your environment.</p>
<h2 id="tasks"><a class="header" href="#tasks">Tasks</a></h2>
<h3 id="1-start-rosmaster"><a class="header" href="#1-start-rosmaster">1 Start rosmaster</a></h3>
<pre><code class="language-bash">roscore
</code></pre>
<h3 id="2-start-turtlesim"><a class="header" href="#2-start-turtlesim">2 Start turtlesim</a></h3>
<p>To start turtlesim, enter the following command in your terminal:</p>
<pre><code class="language-bash">rosrun turtlesim turtlesim_node
</code></pre>
<p>The simulator window should appear, with a random turtle in the center.</p>
<p><img src="Additional_Sections/./Additional_Sections/turtlesim_node-turtle1.png" alt="turtlesim_node-turtle1.png" /></p>
<p>In the terminal under the command, you will see messages from the node:</p>
<pre><code class="language-bash">[ INFO] [1622133713.331795042]: Starting turtlesim with node name /turtlesim
[ INFO] [1622133713.335199049]: Spawning turtle [turtle1] at x=[5.544445], y=[5.544445], theta=[0.000000]
</code></pre>
<p>Here you can see your default turtle’s name is <code>turtle1</code>, and the default coordinates where it spawns.</p>
<h3 id="3-use-turtlesim"><a class="header" href="#3-use-turtlesim">3 Use turtlesim</a></h3>
<p>Open a new terminal and source ROS again.</p>
<p>Now you will run a new node to control the turtle in the first node:</p>
<pre><code class="language-bash">rosrun turtlesim turtle_teleop_key
</code></pre>
<p>At this point you should have four windows open: a terminal running <code>roscore</code>, a terminal running <code>turtlesim_node</code>, a terminal running <code>turtle_teleop_key</code> and the turtlesim window. Arrange these windows so that you can see the turtlesim window, but also have the terminal running <code>turtle_teleop_key</code> active so that you can control the turtle in turtlesim.</p>
<p>Use the arrow keys on your keyboard to control the turtle. It will move around the screen, using its attached “pen” to draw the path it followed so far.</p>
<blockquote>
<p><strong>Note</strong>: Pressing an arrow key will only cause the turtle to move a short distance and then stop. This is because, realistically, you wouldn’t want a robot to continue carrying on an instruction if, for example, the operator lost the connection to the robot.</p>
</blockquote>
<p>You can see the nodes and their associated services, topics using the list command:</p>
<pre><code class="language-bash">rosnode list
rostopic list
rosservice list
</code></pre>
<p>You will learn more about these concepts in the coming tutorials. Since the goal of this tutorial is only to get a general overview of turtlesim, we will use rqt (a graphical user interface for ROS) to look at services a little closer.</p>
<h3 id="4-run-rqt"><a class="header" href="#4-run-rqt">4 Run rqt</a></h3>
<p>Open a new terminal to run <code>rqt</code>:</p>
<pre><code class="language-bash">rqt
</code></pre>
<p>After running rqt the first time, the window will be blank. No worries; just select Plugins &gt; Services &gt; Service Caller from the menu bar at the top.</p>
<blockquote>
<p><strong>Note</strong>: It may take some time for rqt to locate all the plugins itself. If you click on Plugins, but don’t see Services or any other options, you should close rqt, enter the command <code>rqt --force-discover</code> in your terminal.</p>
</blockquote>
<p>Use the refresh button to the left of the <strong>Service</strong> dropdown list to ensure all the services of your turtlesim node are available.</p>
<p>Click on the Service dropdown list to see turtlesim’s services, and select the <code>/spawn</code> service.</p>
<h4 id="41-try-the-spawn-service"><a class="header" href="#41-try-the-spawn-service">4.1 Try the spawn service</a></h4>
<p>Let’s use rqt to call the <code>/spawn</code> service. You can guess from its name that <code>/spawn</code> will create another turtle in the turtlesim window.</p>
<p>Give the new turtle a unique name, like <code>turtle2</code> by double-clicking between the empty single quotes in the Expression column. You can see that this expression corresponds to the <strong>name</strong> value, and is of type <strong>string</strong>.</p>
<p>Enter new coordinates for the turtle to spawn at, like <code>x = 1.0</code> and <code>y = 1.0</code>.</p>
<p><img src="Additional_Sections/./Additional_Sections/rqt-spawn-turtle2.png" alt="rqt-spawn-turtle2.png" /></p>
<blockquote>
<p><strong>Note</strong>: If you try to spawn a new turtle with the same name as an existing turtle, like your default <code>turtle1</code>, you will get an error message in the terminal running <code>turtlesim_node</code>:</p>
</blockquote>
<pre><code class="language-bash">[ERROR] [1622134917.034342076]: A turtled named [turtle1] already exists
</code></pre>
<p>To spawn turtle2, you have to call the service by clicking the <strong>Call</strong> button on the upper right side of the rqt window.</p>
<p>You will see a new turtle (again with a random design) spawn at the coordinates you input for <strong>x</strong> and <strong>y</strong>.</p>
<p>If you refresh the service list in rqt, you will also see that now there are services related to the new turtle, <code>/turtle2/…</code>, in addition to <code>/turtle1/…</code>.</p>
<h4 id="42-try-the-set_pen-service"><a class="header" href="#42-try-the-set_pen-service">4.2 Try the set_pen service</a></h4>
<p>Now let’s give turtle1 a unique pen using the <code>/set_pen</code> service:</p>
<p><img src="Additional_Sections/./Additional_Sections/rqt-set-pen-turtle1.png" alt="rqt-set-pen-turtle1.png" /></p>
<p>The values for <strong>r</strong>, <strong>g</strong> and <strong>b</strong>, between 0 and 255, will set the color of the pen turtle1 draws with, and <strong>width</strong> sets the thickness of the line.</p>
<p>To have turtle1 draw with a distinct red line, change the value of <strong>r</strong> to 255, and the value of width to <strong>5</strong>. Don’t forget to call the service after updating the values.</p>
<p>If you return to the terminal where <code>turtle_teleop_node</code> is running and press the arrow keys, you will see turtle1’s pen has changed.</p>
<p><img src="Additional_Sections/./Additional_Sections/turtlesim-set-pen-turtle1.png" alt="turtlesim-set-pen-turtle1.png" /></p>
<p>You’ve probably noticed that there’s no way to move turtle2. You can accomplish this by remapping turtle1’s <code>cmd_vel</code> topic onto turtle2.</p>
<h3 id="5-remapping"><a class="header" href="#5-remapping">5 Remapping</a></h3>
<p>In a new terminal, source ROS, and run:</p>
<pre><code class="language-bash">rosrun turtlesim turtlesim_node __name:=turtle2 --ros-args --remap turtle1/cmd_vel:=turtle2/cmd_vel
</code></pre>
<blockquote>
<p><strong>Note</strong>: Notice that __name:=turtle2 starts the node with name <code>turtle2</code>. This avoids conflicts if we start two nodes with same name.</p>
</blockquote>
<p>Now you can move turtle2 when this terminal is active, and turtle1 when the other terminal running the <code>turtle_teleop_key</code> is active.</p>
<p><img src="Additional_Sections/./Additional_Sections/turtlesim-two-turtles.png" alt="turtlesim-two-turtles.png" /></p>
<h3 id="close-turtlesim"><a class="header" href="#close-turtlesim">Close turtlesim</a></h3>
<p>To stop the simulation, you can simply close the terminal windows where you ran <code>turtlesim_node</code> and <code>turtle_teleop_key</code>. If you want to keep those terminals open, but end the simulation, you can enter Ctrl + C in the turtlesim_node terminal, and q in the teleop terminal.</p>
<h2 id="summary-1"><a class="header" href="#summary-1">Summary</a></h2>
<p>Using turtlesim and rqt is a great way to learn the core concepts of ROS.</p>
<hr />
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="understanding-ros-nodes"><a class="header" href="#understanding-ros-nodes">Understanding ROS nodes</a></h1>
<p><strong>Goal</strong>: Learn about the function of nodes in ROS, and the tools to interact with them.</p>
<h2 id="background-1"><a class="header" href="#background-1">Background</a></h2>
<h3 id="1-the-ros-graph"><a class="header" href="#1-the-ros-graph">1 The ROS graph</a></h3>
<p>Over the next few tutorials, you will learn about a series of core ROS concepts that make up what is referred to as the “ROS graph”.</p>
<p>The ROS graph is a network of ROS elements processing data together at one time. It encompasses all executables and the connections between them if you were to map them all out and visualize them.</p>
<h3 id="2-nodes-in-ros"><a class="header" href="#2-nodes-in-ros">2 Nodes in ROS</a></h3>
<p>Each node in ROS should be responsible for a single, module purpose (e.g. one node for controlling wheel motors, one node for controlling a laser range-finder, etc). Each node can send and receive data to other nodes via topics, services, actions, or parameters.</p>
<p><img src="Additional_Sections/./Additional_Sections/node-graph.gif" alt="node-graph.gif" /></p>
<p>A full robotic system is comprised of many nodes working in concert.</p>
<h2 id="prerequisites-2"><a class="header" href="#prerequisites-2">Prerequisites</a></h2>
<p>As always, don’t forget to source ROS in every new terminal you open. Also, run <code>roscore</code> in a
separate terminal.</p>
<h2 id="tasks-1"><a class="header" href="#tasks-1">Tasks</a></h2>
<h3 id="1-rosrun"><a class="header" href="#1-rosrun">1 rosrun</a></h3>
<p>The command <code>rosrun</code> launches an executable from a package.</p>
<pre><code class="language-bash">rosrun &lt;package_name&gt; &lt;executable_name&gt;
</code></pre>
<p>To run turtlesim, open a new terminal, and enter the following command:</p>
<pre><code class="language-bash">rosrun turtlesim turtlesim_node
</code></pre>
<p>Here, the package name is <code>turtlesim</code> and the executable name is <code>turtlesim_node</code>.</p>
<p>We still don’t know the node name, however. You can find node names by using <code>rosnode list</code></p>
<h3 id="2-rosnode-list"><a class="header" href="#2-rosnode-list">2 rosnode list</a></h3>
<p><code>rosnode list</code> will show you the names of all running nodes. This is especially useful when you want to interact with a node, or when you have a system running many nodes and need to keep track of them.</p>
<p>Open a new terminal while turtlesim is still running in the other one, and enter the following command:</p>
<pre><code class="language-bash">rosnode list
</code></pre>
<p>The terminal will return the node name:</p>
<pre><code class="language-bash">/rosout
/turtlesim
</code></pre>
<p>Open another new terminal and start the teleop node with the command:</p>
<pre><code class="language-bash">rosrun turtlesim turtle_teleop_key
</code></pre>
<p>Here, we are searching the <code>turtlesim</code> package again, this time for the executable named <code>turtle_teleop_key</code>.</p>
<p>Return to the terminal where you ran <code>rosnode list</code> and run it again. You will now see the names of two active nodes:</p>
<pre><code class="language-bash">/rosout
/teleop_turtle
/turtlesim
</code></pre>
<h4 id="21-remapping"><a class="header" href="#21-remapping">2.1 Remapping</a></h4>
<p><a href="http://wiki.ros.org/Remapping%20Arguments">Remapping</a> allows you to reassign default node properties, like node name, topic names, service names, etc., to custom values. In the last tutorial, you used remapping on <code>turtle_teleop_key</code> to change the default turtle being controlled.</p>
<p>Now, lets reassign the name of our <code>/turtlesim</code> node. In a new terminal, run the following command:</p>
<pre><code class="language-bash">rosrun turtlesim turtlesim_node __name:=my_turtle
</code></pre>
<p>Since you’re calling <code>rosrun</code> on turtlesim again, another turtlesim window will open. However, now if you return to the terminal where you ran <code>rosnode list</code>, and run it again, you will see three node names:</p>
<pre><code class="language-bash">/my_turtle
/rosout
/teleop_turtle
/turtlesim
</code></pre>
<h3 id="3-rosnode-info"><a class="header" href="#3-rosnode-info">3 rosnode info</a></h3>
<p>Now that you know the names of your nodes, you can access more information about them with:</p>
<pre><code class="language-bash">rosnode info &lt;node_name&gt;
</code></pre>
<p>To examine your latest node, <code>my_turtle</code>, run the following command:</p>
<pre><code class="language-bash">rosnode info /my_turtle
</code></pre>
<p><code>rosnode info</code> returns a list of subscribers, publishers, services, and actions (the ROS graph connections) that interact with that node. The output should look like this:</p>
<pre><code class="language-bash">Node [/my_turtle]
Publications: 
 * /rosout [rosgraph_msgs/Log]
 * /turtle1/color_sensor [turtlesim/Color]
 * /turtle1/pose [turtlesim/Pose]

Subscriptions: 
 * /turtle1/cmd_vel [geometry_msgs/Twist]

Services: 
 * /clear
 * /kill
 * /my_turtle/get_loggers
 * /my_turtle/set_logger_level
 * /reset
 * /spawn
 * /turtle1/set_pen
 * /turtle1/teleport_absolute
 * /turtle1/teleport_relative


contacting node http://ros-noetic:44953/ ...
Pid: 878
Connections:
 * topic: /rosout
    * to: /rosout
    * direction: outbound (40097 - 10.104.247.68:60584) [18]
    * transport: TCPROS
 * topic: /turtle1/cmd_vel
    * to: /teleop_turtle (http://ros-noetic:44321/)
    * direction: inbound (58058 - ros-noetic:47853) [17]
    * transport: TCPROS
</code></pre>
<p>Now try running the same command on the <code>/teleop_turtle node</code>, and see how its connections differ from <code>my_turtle</code>.</p>
<p>You will learn more about ROS graph connection concepts in the upcoming tutorials.</p>
<h2 id="summary-2"><a class="header" href="#summary-2">Summary</a></h2>
<p>A node is a fundamental ROS element that serves a single, modular purpose in a robotics system.</p>
<p>In this tutorial, you utilized nodes created from the <code>turtlesim</code> package by running the executables <code>turtlesim_node</code> and <code>turtle_teleop_key</code>.</p>
<p>You learned how to use <code>rosnode list</code> to discover active node names and <code>rosnode info</code> to introspect on a single node. These tools are vital to understanding the flow of data in a complex, real-world robot system.</p>
<hr />
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="understanding-ros-topics"><a class="header" href="#understanding-ros-topics">Understanding ROS topics</a></h1>
<p><strong>Goal</strong>: Use rqt_graph and command line tools to introspect ROS topics.</p>
<h2 id="background-2"><a class="header" href="#background-2">Background</a></h2>
<p>ROS breaks complex systems down into many modular nodes. Topics are a vital element of the ROS graph that act as a bus for nodes to exchange messages.</p>
<p><img src="Additional_Sections/./Additional_Sections/topic-single-publisher-and-single-subscriber.gif" alt="topic-single-publisher-and-single-subscriber.gif" /></p>
<p>A node may publish data to any number of topics and simultaneously have subscriptions to any number of topics.</p>
<p><img src="Additional_Sections/./Additional_Sections/topic-multiple.gif" alt="topic-multiple.gif" /></p>
<p>Topics are one of the important ways that data moves between nodes, and therefore between different parts of the system.</p>
<h2 id="prerequisites-3"><a class="header" href="#prerequisites-3">Prerequisites</a></h2>
<p>As always, don’t forget to source ROS 2 in every new terminal you open. Run <code>roscore</code> in a separate terminal.</p>
<h2 id="tasks-2"><a class="header" href="#tasks-2">Tasks</a></h2>
<h3 id="1-setup"><a class="header" href="#1-setup">1 Setup</a></h3>
<p>By now you should be comfortable starting up turtlesim.</p>
<p>Open a new terminal and run:</p>
<pre><code class="language-bash">rosrun turtlesim turtlesim_node
</code></pre>
<p>Open another terminal and run:</p>
<pre><code class="language-bash">rosrun turtlesim turtle_teleop_key
</code></pre>
<p>Recall from the [previous tutorial] that the names of these nodes are <code>/turtlesim</code> and <code>/teleop_turtle</code> by default.</p>
<h3 id="2-rqt_graph"><a class="header" href="#2-rqt_graph">2 rqt_graph</a></h3>
<p>Throughout this tutorial, we will use <code>rqt_graph</code> to visualize the changing nodes and topics, as well as the connections between them.</p>
<p>To run rqt_graph, open a new terminal and enter the command:</p>
<pre><code class="language-bash">rqt_graph
</code></pre>
<p>You can also open <code>rqt_graph</code> by opening rqt and selecting <strong>Plugins</strong> &gt; <strong>Introspection</strong> &gt; <strong>Nodes Graph</strong>.</p>
<p><img src="Additional_Sections/./Additional_Sections/rqt-graph-rostopic.png" alt="rqt-graph-rostopic.png" /></p>
<p>You should see the above nodes and topic. If you hover your mouse over the topic in the center, you’ll see the color highlighting like in the image above.</p>
<p>The graph is depicting how the <code>/turtlesim</code> node and the <code>/teleop_turtle</code> node are communicating with each other over a topic. The <code>/teleop_turtle</code> node is publishing data (the keystrokes you enter to move the turtle around) to the <code>/turtle1/cmd_vel</code> topic, and the <code>/turtlesim</code> node is subscribed to that topic to receive the data.</p>
<p>The highlighting feature of <strong>rqt_graph</strong> is very helpful when examining more complex systems with many nodes and topics connected in many different ways.</p>
<p><code>rqt_graph</code> is a graphical introspection tool. Now we’ll look at some command line tools for introspecting topics.</p>
<h3 id="rostopic-list"><a class="header" href="#rostopic-list">rostopic list</a></h3>
<p>Running the <code>rostopic list</code> command in a new terminal will return a list of all the topics currently active in the system:</p>
<pre><code class="language-bash">/rosout
/rosout_agg
/statistics
/turtle1/cmd_vel
/turtle1/color_sensor
/turtle1/pose
</code></pre>
<p>Topics have names and types. These attributes, particularly the type, are how nodes know they’re talking about the same information as it moves over topics. To show the topic type run this command:</p>
<pre><code class="language-bash">rostopic type /turtle1/cmd_vel 
</code></pre>
<pre><code class="language-bash">geometry_msgs/Twist
</code></pre>
<p>If you’re wondering where all these topics are in rqt_graph, you can uncheck all the boxes under Hide:</p>
<p><img src="Additional_Sections/./Additional_Sections/rqt-graph-unhidden.png" alt="rqt-graph-unhidden.png" /></p>
<p>For now, though, leave those options checked to avoid confusion.</p>
<h3 id="4-rostopic-echo"><a class="header" href="#4-rostopic-echo">4 rostopic echo</a></h3>
<p>To see the data being published on a topic, use:</p>
<pre><code class="language-bash">rostopic echo &lt;topic_name&gt;
</code></pre>
<p>Since we know that <code>/teleop_turtle</code> publishes data to <code>/turtlesim</code> over the <code>/turtle1/cmd_vel</code> topic, let’s use echo to introspect on that topic:</p>
<pre><code class="language-bash">rostopic echo /turtle1/cmd_vel
</code></pre>
<p>At first, this command won’t return any data. That’s because it’s waiting for <code>/teleop_turtle</code> to publish something.</p>
<p>Return to the terminal where <code>turtle_teleop_key</code> is running and use the arrows to move the turtle around. Watch the terminal where your <code>echo</code> is running at the same time, and you’ll see position data being published for every movement you make:</p>
<pre><code class="language-bash">linear: 
  x: 2.0
  y: 0.0
  z: 0.0
angular: 
  x: 0.0
  y: 0.0
  z: 0.0
---
</code></pre>
<p>Now return to rqt_graph and uncheck the Debug box.</p>
<p><img src="Additional_Sections/./Additional_Sections/rqt-graph-cli.png" alt="rqt-graph-cli.png" /></p>
<p><code>/rostopic_2309_1622187461192</code> is the node created by the <code>echo</code> we just ran (the number will change). Now you can see that the publisher is publishing data over the <code>cmd_vel</code> topic, and two subscribers are subscribed.</p>
<h3 id="5-rostopic-info"><a class="header" href="#5-rostopic-info">5 rostopic info</a></h3>
<p>Topics don’t have to only be point-to-point communication; it can be one-to-many, many-to-one, or many-to-many.</p>
<p>Another way to look at this is running:</p>
<pre><code class="language-bash">rostopic info /turtle1/cmd_vel
</code></pre>
<p>Which will return:</p>
<pre><code class="language-bash">Type: geometry_msgs/Twist

Publishers: 
 * /teleop_turtle (http://ros-noetic:44037/)

Subscribers: 
 * /turtlesim (http://ros-noetic:44297/)
 * /rostopic_2309_1622187461192 (http://ros-noetic:45255/)
</code></pre>
<h3 id="6-rosmsg-show"><a class="header" href="#6-rosmsg-show">6 rosmsg show</a></h3>
<p>Nodes send data over topics using messages. Publishers and subscribers must send and receive the same type of message to communicate.</p>
<p>The topic types we saw earlier after running <code>rostopic type &lt;topic-name&gt;</code> let us know what type of messages each topic can send. Recall that the <code>cmd_vel</code> topic has the type:</p>
<pre><code class="language-bash">geometry_msgs/Twist
</code></pre>
<p>This means that in the package <code>geometry_msgs</code> there is a message called <code>Twist</code>.</p>
<p>Now we can run `rosmsg show <type>.msg on this type to learn its details, specifically, what structure of data the message expects.</p>
<pre><code class="language-bash">rosmsg show geometry_msgs/Twist
</code></pre>
<pre><code class="language-bash">geometry_msgs/Vector3 linear
  float64 x
  float64 y
  float64 z
geometry_msgs/Vector3 angular
  float64 x
  float64 y
  float64 z
</code></pre>
<p>This tells you that the <code>/turtlesim</code> node is expecting a message with two vectors, <code>linear</code> and <code>angular</code>, of three elements each. If you recall the data we saw <code>/teleop_turtle</code> passing to <code>/turtlesim</code> with the <code>echo</code> command, it’s in the same structure:</p>
<pre><code class="language-bash">linear: 
  x: 2.0
  y: 0.0
  z: 0.0
angular: 
  x: 0.0
  y: 0.0
  z: 0.0
---
</code></pre>
<h3 id="rostopic-pub"><a class="header" href="#rostopic-pub">rostopic pub</a></h3>
<p>Now that you have the message structure, you can publish data onto a topic directly from the command line using:</p>
<pre><code class="language-bash">rostopic pub &lt;topic_name&gt; &lt;msg_type&gt; '&lt;args&gt;'
</code></pre>
<p>The <code>'&lt;args&gt;'</code> argument is the actual data you’ll pass to the topic, in the structure you just discovered in the previous section.</p>
<p>It’s important to note that this argument needs to be input in YAML syntax. Input the full command like so:</p>
<pre><code class="language-bash">rostopic pub -1 /turtle1/cmd_vel geometry_msgs/Twist &quot;{linear: {x: 2.0, y: 0.0, z: 0.0}, angular: {x: 0.0, y: 0.0, z: 1.8}}&quot;
</code></pre>
<p><code>-1</code> is an optional argument meaning &quot;publish one message then exit&quot;.</p>
<p>You will receive the following message in the terminal:</p>
<pre><code class="language-bash">publishing and latching message for 3.0 seconds
</code></pre>
<p>And you will see your turtle move like so:</p>
<p><img src="Additional_Sections/./Additional_Sections/turtle1-rostopic-pub-once.png" alt="turtle1-rostopic-pub-once.png" /></p>
<p>The turtle (and commonly the real robots which it is meant to emulate) require a steady stream of commands to operate continuously. So, to get the turtle to keep moving, you can run:</p>
<pre><code class="language-bash">rostopic pub -r 1 /turtle1/cmd_vel geometry_msgs/Twist &quot;{linear: {x: 2.0, y: 0.0, z: 0.0}, angular: {x: 0.0, y: 0.0, z: 1.8}}&quot;
</code></pre>
<p>The difference here is the removal of the <code>-1</code> option and the addition of the <code>--rate 1</code> option, which tells <code>rostopic pub</code> to publish the command in a steady stream at 1 Hz.</p>
<p><img src="Additional_Sections/./Additional_Sections/turtle1-rostopic-pub.gif" alt="turtle1-rostopic-pub.gif" /></p>
<p>You can refresh <strong>rqt_graph</strong> to see what’s happening graphically. You will see the <code>rostopic pub ... </code> node (<code>/rostopic_3050_1622189437717</code>) is publishing over the <code>/turtle1/cmd_vel</code> topic, and is being received by both the <code>rostopic echo ... </code> node (<code>/rostopic_2309_1622187461192</code>) and the <code>/turtlesim node</code> now.</p>
<p><img src="Additional_Sections/./Additional_Sections/rqt_graph-pub.png" alt="rqt_graph-pub.png" /></p>
<p>Finally, you can run <code>echo</code> on the <code>pose</code> topic and recheck rqt_graph:</p>
<pre><code class="language-bash">rostopic echo /turtle1/pose
</code></pre>
<p><img src="Additional_Sections/./Additional_Sections/rqt_graph-echo-pose.png" alt="rqt_graph-echo-pose.png" /></p>
<p>In this case, <code>/turtlesim</code> is now publishing to the <code>pose</code> topic, and a new <code>echo</code> node is subscribed.</p>
<h3 id="8-rostopic-hz"><a class="header" href="#8-rostopic-hz">8 rostopic hz</a></h3>
<p>For one last introspection on this process, you can report the rate at which data is published using:</p>
<pre><code class="language-bash">rostopic hz /turtle1/pose 
</code></pre>
<p>It will return data on the rate at which the <code>/turtlesim</code> node is publishing data to the <code>pose</code> topic.</p>
<pre><code class="language-bash">average rate: 62.527
	min: 0.015s max: 0.017s std dev: 0.00041s window: 62
</code></pre>
<p>Recall that you set the rate of <code>turtle1/cmd_vel</code> to publish at a steady 1 Hz using <code>rostopic pub -r 1</code>. If you run the above command with <code>turtle1/cmd_vel</code> instead of <code>turtle1/pose</code>, you will see an average reflecting that rate.</p>
<h3 id="9-clean-up"><a class="header" href="#9-clean-up">9 Clean up</a></h3>
<p>At this point you’ll have a lot of nodes running. Don’t forget to stop them, either by closing the terminal windows or entering <code>Ctrl+C</code> in each terminal.</p>
<h2 id="summary-3"><a class="header" href="#summary-3">Summary</a></h2>
<p>Nodes publish information over topics, which allows any number of other nodes to subscribe to and access that information. In this tutorial you examined the connections between several nodes over topics using rqt_graph and command line tools. You should now have a good idea of how data moves around a ROS system.</p>
<hr />
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="understanding-ros-services"><a class="header" href="#understanding-ros-services">Understanding ROS Services</a></h1>
<p><strong>Goal</strong>: Learn about services in ROS using command line tools.</p>
<h2 id="background-3"><a class="header" href="#background-3">Background</a></h2>
<p>Services are another method of communication for nodes in the ROS graph. Services are based on a call-and-response model, versus topics’ publisher-subscriber model. While topics allow nodes to subscribe to data streams and get continual updates, services only provide data when they are specifically called by a client.</p>
<p><img src="Additional_Sections/./Additional_Sections/Service-SingleServiceClient.gif" alt="Service-SingleServiceClient.gif" /></p>
<p><img src="Additional_Sections/./Additional_Sections/Service-MultipleServiceClient.gif" alt="Service-MultipleServiceClient.gif" /></p>
<h2 id="prerequisites-4"><a class="header" href="#prerequisites-4">Prerequisites</a></h2>
<p>As always, don’t forget to source ROS 2 in every new terminal you open.</p>
<p>Run <code>roscore</code> in a separate terminal.</p>
<h2 id="tasks-3"><a class="header" href="#tasks-3">Tasks</a></h2>
<h3 id="1-setup-1"><a class="header" href="#1-setup-1">1 Setup</a></h3>
<p>Start up the two turtlesim nodes, <code>/turtlesim</code> and <code>/teleop_turtle</code>.</p>
<p>Open a new terminal and run:</p>
<pre><code class="language-bash">rosrun turtlesim turtlesim_node
</code></pre>
<p>Open another terminal and run:</p>
<pre><code class="language-bash">rosrun turtlesim turtle_teleop_key
</code></pre>
<h3 id="2-rosservice-list"><a class="header" href="#2-rosservice-list">2 rosservice list</a></h3>
<p>Running the <code>rosservice list</code> command in a new terminal will return a list of all the services currently active in the system:</p>
<pre><code class="language-bash">/clear
/kill
/reset
/rosout/get_loggers
/rosout/set_logger_level
/spawn
/teleop_turtle/get_loggers
/teleop_turtle/set_logger_level
/turtle1/set_pen
/turtle1/teleport_absolute
/turtle1/teleport_relative
/turtlesim/get_loggers
/turtlesim/set_logger_level
</code></pre>
<p>For now, let’s focus on the turtlesim-specific services, <code>/clear</code>, <code>/kill</code>, <code>/reset</code>, <code>/spawn</code>, <code>/turtle1/set_pen</code>, <code>/turtle1/teleport_absolute</code>, and <code>/turtle1/teleport_relative</code>. You may recall interacting with some of these services using rqt in the `[<a href="Additional_Sections/./Additional_Sections/introducing_turtlesim_and_rqt.html">“Introducing turtlesim and rqt”</a> tutorial.</p>
<h3 id="3-rosservice-type"><a class="header" href="#3-rosservice-type">3 rosservice type</a></h3>
<p>Services have types that describe how the request and response data of a service is structured. Service types are defined similarly to topic types, except service types have two parts: one message for the request and another for the response.</p>
<p>To find out the type of a service, use the command:</p>
<pre><code class="language-bash">rosservice type &lt;service_name&gt;
</code></pre>
<p>Let’s take a look at turtlesim’s <code>/clear</code> service. In a new terminal, enter the command:</p>
<pre><code class="language-bash">rosservice type /clear
</code></pre>
<p>Which should return:</p>
<pre><code class="language-bash">std_srvs/Empty
</code></pre>
<p>The <code>Empty</code> type means the service call sends no data when making a request and receives no data when receiving a response.</p>
<h3 id="4-rosservice-find"><a class="header" href="#4-rosservice-find">4 rosservice find</a></h3>
<p>If you want to find all the services of a specific type, you can use the command:</p>
<pre><code class="language-bash">rosservice find &lt;type_name&gt;
</code></pre>
<p>For example, you can find all the <code>Empty</code> typed services like this:</p>
<pre><code class="language-bash">rosservice find std_srvs/Empty 
</code></pre>
<p>Which will return:</p>
<pre><code class="language-bash">/clear
/reset
</code></pre>
<h3 id="5-rossrv-show"><a class="header" href="#5-rossrv-show">5 rossrv show</a></h3>
<p>You can call services from the command line, but first you need to know the structure of the input arguments.</p>
<pre><code class="language-bash">rossrv show &lt;type_name&gt;
</code></pre>
<p>To run this command on the <code>/clear</code> service’s type, <code>Empty</code>:</p>
<pre><code class="language-bash">rossrv show std_srvs/Empty 
</code></pre>
<p>Which will return:</p>
<pre><code class="language-bash">---
</code></pre>
<p>The <code>---</code> separates the request structure (above) from the response structure (below). But, as you learned earlier, the <code>Empty</code> type doesn’t send or receive any data. So, naturally, its structure is blank.</p>
<p>Let’s introspect a service with a type that sends and receives data, like <code>/spawn</code>. From the results of <code>rosservice list</code> and <code>rosservice type</code>, we know <code>/spawn</code>’s type is <code>turtlesim/Spawn</code>.</p>
<p>To see the arguments in a <code>/spawn</code> call-and-request, run the command:</p>
<pre><code class="language-bash">rossrv show turtlesim/Spawn 
</code></pre>
<p>Which will return:</p>
<pre><code class="language-bash">float32 x
float32 y
float32 theta
string name
---
string name
</code></pre>
<p>The information above the <code>---</code> line tells us the arguments needed to call <code>/spawn</code>. <code>x</code>, <code>y</code> and <code>theta</code> determine the location of the spawned turtle, and <code>name</code> is clearly optional.</p>
<p>The information below the line isn’t something you need to know in this case, but it can help you understand the data type of the response you get from the call.</p>
<h3 id="6-rosservice-call"><a class="header" href="#6-rosservice-call">6 rosservice call</a></h3>
<p>Now that you know what a service type is, how to find a service’s type, and how to find the structure of that type’s arguments, you can call a service using:</p>
<pre><code class="language-bash">rosservice call &lt;service_name&gt; &lt;arguments&gt;
</code></pre>
<p>The <code>&lt;arguments&gt;</code> part is optional. For example, you know that <code>Empty</code> typed services don’t have any arguments:</p>
<pre><code class="language-bash">rosservice call /clear
</code></pre>
<p>This command will clear the turtlesim window of any lines your turtle has drawn.</p>
<p><img src="Additional_Sections/./Additional_Sections/rosservice-call-clear-before.png" alt="rosservice-call-clear-before.png" /></p>
<p><img src="Additional_Sections/./Additional_Sections/rosservice-call-clear-after.png" alt="rosservice-call-clear-after.png" /></p>
<p>Now let’s spawn a new turtle by calling <code>/spawn</code> and inputting arguments. Input <code>&lt;arguments&gt;</code> in a service call from the command-line need to be in YAML syntax.</p>
<p>Enter the command:</p>
<pre><code class="language-bash">rosservice call /spawn &quot;{x: 2, y: 2, theta: 0.2, name: ''}&quot;
</code></pre>
<p>You will get this output on terminal:</p>
<pre><code class="language-bash">name: &quot;turtle2&quot;
</code></pre>
<p>Your turtlesim window will update with the newly spawned turtle right away:</p>
<p><img src="Additional_Sections/./Additional_Sections/rosservice-call-spawn.png" alt="rosservice-call-spawn.png" /></p>
<h2 id="summary-4"><a class="header" href="#summary-4">Summary</a></h2>
<p>Nodes can communicate using services in ROS. Unlike a topic - a one way communication pattern where a node publishes information that can be consumed by one or more subscribers - a service is a request/response pattern where a client makes a request to a node providing the service and the service processes the request and generates a reponse.</p>
<p>You generally don’t want to use a service for continuous calls; topics or even actions would be better suited.</p>
<p>In this tutorial you used command line tools to identify, elaborate on, and call services.</p>
<hr />
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="tasks-4"><a class="header" href="#tasks-4">Tasks</a></h1>
<h2 id="tasks-based-on-turtlesim"><a class="header" href="#tasks-based-on-turtlesim">tasks based on turtlesim</a></h2>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="task-0"><a class="header" href="#task-0">Task 0</a></h1>
<h2 id="welcome-to-task-0-"><a class="header" href="#welcome-to-task-0-">Welcome to Task 0 !!!</a></h2>
<hr />
<h2>The aim of this task is to make you familiar with rostopics and rosserices. You
need to install the mentioned software &amp; libraries by running the provided instructions in the <strong>provided sequence only</strong>; and if any error occurs at any step, please do <strong>not</strong> proceed unless the error has been rectified from your end.</h2>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="problem-statement"><a class="header" href="#problem-statement">Problem Statement</a></h1>
<ul>
<li>The objective of this task is to spawn two turtles in a <strong>turtlesim</strong> window and make one turtle follow another.</li>
</ul>
<blockquote>
<p><strong>Note</strong>: The name of turtles should be <code>turtle1</code> and <code>turtle2</code> respectively with <code>turtle2</code> following <code>turtle1</code>. <code>turtle1</code> should be spawned at default coordinates (5.544445, 5.544445, 0) and <code>turtle2</code> at (1.0, 1.0, 0.0).</p>
</blockquote>
<ul>
<li>You can do this by creating a node name, <code>node_catch_the_turtle</code> with a python script, <code>node_catch_the_turtle.py</code>.</li>
</ul>
<p><strong>Optional</strong>:</p>
<ul>
<li>
<p>Change the color of the pen of turtles.</p>
<ul>
<li><strong>turtle1</strong>
<ul>
<li><code>r: 255</code></li>
<li><code>g: 255</code></li>
<li><code>b: 0</code></li>
<li><code>width: 5</code></li>
</ul>
</li>
<li><strong>turtle2</strong>
<ul>
<li><code>r: 255</code></li>
<li><code>g: 0</code></li>
<li><code>b: 0</code></li>
<li><code>width: 4</code></li>
</ul>
</li>
</ul>
</li>
<li>
<p>Change the background to <strong>forestgreen</strong>. </p>
<ul>
<li><code>background_r: 34</code></li>
<li><code>background_g: 139</code></li>
<li><code>background_b: 34</code></li>
</ul>
</li>
</ul>
<h2 id="procedure"><a class="header" href="#procedure">Procedure</a></h2>
<ol>
<li>First, create a package name <code>pkg_task0</code>, within your catkin workspace. Once done, compile and source the packages.</li>
</ol>
<pre><code class="language-bash">cd ~/workspace
catkin_make
source devel/setup.bash
</code></pre>
<ol>
<li>Within this package, you should have a <code>scripts</code> folder inside which you'll create a python script, named <code>node_catch_the_turtle.py</code>.</li>
</ol>
<blockquote>
<p><strong>Note</strong>: Fill the script with proper programming ethics. Doing this will help us understand your code better and quicker than usual.</p>
</blockquote>
<ol>
<li>After completing the python script. Make it executable, if it isn't already. To do that, enter the following code.</li>
</ol>
<pre><code class="language-bash">chmod +x ~/workspace/src/pkg_task0/scripts/node_catch_the_turtle.py
</code></pre>
<ol>
<li>Before executing make sure that <code>roscore</code> is running along with <code>turtlesim_node</code>. You can either run them in separate terminals or simply create a <code>task0.launch</code> file inside the <code>~/workspace/src/pkg_task0/launch/</code> folder. Launch file can run multiple nodes unlike a python/cpp script. Run the launch file, enter,</li>
</ol>
<pre><code class="language-bash">roslaunch pkg_task0 task0.launch 
</code></pre>
<ul>
<li>This should run these processes in parallel.
<ul>
<li>roscore</li>
<li>turtlesim_node</li>
<li>turtle_teleop_key</li>
<li>node_catch_the_turtle.py</li>
</ul>
</li>
</ul>
<h2 id="hints"><a class="header" href="#hints">Hints</a></h2>
<ul>
<li>You can use linear velocity as well as angular velocity with some combination to get this done. </li>
<li>Keep tracking the distance travelled so as to know when to stop.</li>
</ul>
<hr />
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="expected-output"><a class="header" href="#expected-output">Expected Output</a></h1>
<ul>
<li>The following videos can be considered as a valid output.</li>
</ul>
<p><img src="tasks/task0/./tasks/task0/expected-output.gif" alt="expected-output.gif" /></p>
<blockquote>
<p><strong>Note</strong>: First, let <code>turtle2</code> reach <code>turtle1</code> then only move <code>turtle1</code>.</p>
</blockquote>
<ul>
<li>To know whether the nodes are talking to each other as expected one can use the command <code>rqt_graph</code>. Below, you can find an expected graph for this task.</li>
</ul>
<p><img src="tasks/task0/./tasks/task0/rqt_graph-output.png" alt="rqt_graph-output.png" /></p>
<ul>
<li>Your terminal should look like this at the startup of roslaunch server.</li>
</ul>
<pre><code class="language-bash">ubuntu@ros-noetic:~$ roslaunch pkg_task0 turtle-task.launch 
... logging to /home/ubuntu/.ros/log/6f7d513a-c084-11eb-9883-a5ac155eafae/roslaunch-ros-noetic-10780.log
Checking log directory for disk usage. This may take a while.
Press Ctrl-C to interrupt
Done checking log file disk usage. Usage is &lt;1GB.

started roslaunch server http://ros-noetic:34763/

SUMMARY
========

PARAMETERS
 * /node_turtlesim_node/background_b: 34
 * /node_turtlesim_node/background_g: 139
 * /node_turtlesim_node/background_r: 34
 * /rosdistro: noetic
 * /rosversion: 1.15.11

NODES
  /
    node_catch_the_turtle (pkg_task0/node_catch_the_turtle.py)
    node_turtle_teleop_key (turtlesim/turtle_teleop_key)
    node_turtlesim_node (turtlesim/turtlesim_node)

auto-starting new master
process[master]: started with pid [10788]
ROS_MASTER_URI=http://localhost:11311

setting /run_id to 6f7d513a-c084-11eb-9883-a5ac155eafae
process[rosout-1]: started with pid [10798]
started core service [/rosout]
process[node_turtlesim_node-2]: started with pid [10801]
process[node_turtle_teleop_key-3]: started with pid [10805]
process[node_catch_the_turtle-4]: started with pid [10807]
Reading from keyboard
---------------------------
Use arrow keys to move the turtle. 'q' to quit.
[ INFO] [1622296061.324015602]: Starting turtlesim with node name /node_turtlesim_node
[ INFO] [1622296061.328553969]: Spawning turtle [turtle1] at x=[5.544445], y=[5.544445], theta=[0.000000]
[ INFO] [1622296061.657708547]: Spawning turtle [turtle2] at x=[1.000000], y=[1.000000], theta=[0.000000]
</code></pre>
<hr />
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="recording-logs"><a class="header" href="#recording-logs">Recording Logs</a></h1>
<ul>
<li>
<p>ROS allows us to record a log of the messages that occurred in a given time period. This is like recording a data stream. The ROS utility which does this is called rosbag, and the command to capture the data is <code>rosbag record</code>.</p>
</li>
<li>
<p>Create a folder called bag_files in your package as a save destination for the bag files.</p>
</li>
<li>
<p>You can run the rosbag record command separately on the command line. But to not loose any data you will have to start recording precisely at the same moment your turtle starts moving. Hence it is a much more preferable option to include the rosbag recording in your launch file itself.</p>
</li>
<li>
<p>Add the following lines to your launch file to have the rosbag record run in parallel with your task. Some parameters are explained below:</p>
</li>
</ul>
<pre><code class="language-xml">    &lt;arg name=&quot;record&quot; default=&quot;false&quot;/&gt;
    &lt;arg name=&quot;duration&quot; default=&quot;100&quot;/&gt;
    &lt;arg name=&quot;rec_name&quot; default=&quot;turtle_record.bag&quot;/&gt;

    &lt;group if=&quot;$(arg record)&quot;&gt;
        &lt;node name=&quot;rosbag_record_turtle&quot; pkg=&quot;rosbag&quot; type=&quot;record&quot;
            args=&quot;record -O $(find pkg_task0)/bag_files/$(arg rec_name) --duration=$(arg duration) --chunksize=10 /turtle1/cmd_vel /turtle1/pose /turtle2/cmd_vel /turtle2/pose&quot; output=&quot;screen&quot; /&gt;
    &lt;/group&gt;
</code></pre>
<blockquote>
<p><strong>Note</strong>: Make sure you have added these line before <code>&lt;/launch&gt;</code> line. And the 3 nodes, the turtlesim, teleop_key and your python script node, are already present within this launch file, for desire recording.</p>
</blockquote>
<ul>
<li>The <code>arg_name</code> tags are roslaunch parameters, meaning they can be called while calling your roslaunch file, for example:</li>
</ul>
<pre><code class="language-bash">roslaunch pkg_task0 task0.launch record:=true rec_name:=my_turtle.bag
</code></pre>
<ul>
<li>This command will.. 
<ul>
<li>Start recording.</li>
<li>Should start turtlesim and turtle_teleop_key node.</li>
<li>Should start your python script node.</li>
<li>And name the resultant bag file as <strong>my_turtle.bag</strong>.</li>
</ul>
</li>
</ul>
<p>while still retaining the default value (in seconds) for the duration parameter.</p>
<p>Thus using these parameters along with your launch file will record a bag file of appropriate <code>duration</code>. Also, Make sure that the task is completed within the recording duration. <strong>If not then shorten the duration during which you run turtle1 using teleop_key.</strong></p>
<ul>
<li>If the rosbag has started, the message:</li>
</ul>
<pre><code class="language-bash">process[rosbag_record_turtle-5]: started with pid [1056]
</code></pre>
<p>will appear on your terminal within the roslaunch output window.</p>
<blockquote>
<p><strong>Note</strong>:  bag files with the same name will be overwritten by the rosbag utility without a prompt/warning. Make sure you provide proper name for each iteration if you want to save them all. </p>
</blockquote>
<hr />
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="solution"><a class="header" href="#solution">Solution</a></h1>
<blockquote>
<p><strong>Note</strong>: Remove this md page from mdbook and delete scripts from <code>src/tasks/task0/</code> It shows one of the possible solution with autoeval script.</p>
</blockquote>
<p><code>turtle-task.launch</code></p>
<pre><code class="language-xml">&lt;launch&gt;
    
    &lt;node pkg=&quot;turtlesim&quot; type=&quot;turtlesim_node&quot; name=&quot;node_turtlesim_node&quot; output=&quot;screen&quot;&gt;
        &lt;param name=&quot;/background_r&quot; value=&quot;34&quot; /&gt;
        &lt;param name=&quot;/background_g&quot; value=&quot;139&quot; /&gt;
        &lt;param name=&quot;/background_b&quot; value=&quot;34&quot; /&gt;
    &lt;/node&gt;
    
    &lt;node pkg=&quot;turtlesim&quot; type=&quot;turtle_teleop_key&quot; name=&quot;node_turtle_teleop_key&quot; output=&quot;screen&quot; /&gt;
    &lt;node pkg=&quot;pkg_task0&quot; type=&quot;node_catch_the_turtle.py&quot; name=&quot;node_catch_the_turtle&quot; output=&quot;screen&quot; /&gt;

    &lt;arg name=&quot;record&quot; default=&quot;false&quot;/&gt;
    &lt;arg name=&quot;duration&quot; default=&quot;100&quot;/&gt;
    &lt;arg name=&quot;rec_name&quot; default=&quot;turtle_record.bag&quot;/&gt;

    &lt;group if=&quot;$(arg record)&quot;&gt;
        &lt;node name=&quot;rosbag_record_turtle&quot; pkg=&quot;rosbag&quot; type=&quot;record&quot;
        args=&quot;record -O $(find pkg_task0)/bag_files/$(arg rec_name) --duration=$(arg duration) --chunksize=10 /turtle1/cmd_vel /turtle1/pose /turtle2/cmd_vel /turtle2/pose&quot; output=&quot;screen&quot; /&gt;

    &lt;/group&gt;
    
&lt;/launch&gt;
</code></pre>
<center><a href="tasks/task0/tasks/task0/turtle-task.launch" download><button>Download</button></a></center>
<p><code>node_catch_the_turtle.py</code></p>
<pre><code class="language-python">#!/usr/bin/env python3

import rospy
from geometry_msgs.msg import Twist
from turtlesim.msg import Pose
from turtlesim.srv import Spawn, SpawnResponse
from turtlesim.srv import SetPen
import math


class turtle:
    '''This class is used to spawn another turtle on turtlesim env and make it follow original
    spawned turtle.'''

    # Constructor
    def __init__(self):

        # Initialize node
        rospy.init_node('node_catch_me_turtle', anonymous=True)

        # Subscribe to pose of turtles
        self.t1_pose_subscriber = rospy.Subscriber(
            '/turtle1/pose', Pose, self.t1_pose_callback)
        self.t2_pose_subscriber = rospy.Subscriber(
            '/turtle2/pose', Pose, self.t2_pose_callback)

        # Spawn second turtle on turtlesim env
        self.spawn_turtle_srv = rospy.ServiceProxy('/spawn', Spawn)
        self.spawn_turtle_srv.wait_for_service()
        rospy.loginfo(self.spawn_turtle_srv.call(
            1.0, 1.0, 0.0, 'turtle2').name)

        # To publish on cmd_vel of turtle2
        self.velocity_publisher = rospy.Publisher(
            '/turtle2/cmd_vel', Twist, queue_size=10)

        # Set pen of both turtles
        self.set_t1_pen_srv = rospy.ServiceProxy('/turtle1/set_pen', SetPen)
        self.set_t2_pen_srv = rospy.ServiceProxy('/turtle2/set_pen', SetPen)
        self.set_t1_pen_srv.wait_for_service()
        self.set_t2_pen_srv.wait_for_service()
        self.set_t1_pen_srv.call(255, 255, 0, 5, 0)  # yellow
        self.set_t2_pen_srv.call(255, 0, 0, 4, 0)   # red

        self.t1_pose = Pose()
        self.t2_pose = Pose()
        self.twist = Twist()
        self.rate = rospy.Rate(10)  # Rate in Hz

    def t1_pose_callback(self, pos_msg):
        self.t1_pose = pos_msg
        self.t1_pose.x = pos_msg.x
        self.t1_pose.y = pos_msg.y

    def t2_pose_callback(self, pos_msg):
        self.t2_pose = pos_msg
        self.t2_pose.x = pos_msg.x
        self.t2_pose.y = pos_msg.y
        self.t2_pose.theta = pos_msg.theta

    def turtle_follow_turtle(self):
        '''This method makes turtle2 follow turtle1.'''

        # Constants to move turtle. Change these to speed up or speed down motion.
        k_linear = 0.5
        k_angular = 4.0

        # Infinite loop
        while not rospy.is_shutdown():

            # Calculate distance between two turtles
            distance = math.sqrt(
                (self.t2_pose.x - self.t1_pose.x)**2 + (self.t2_pose.y - self.t1_pose.y)**2)
            linear_speed = k_linear * distance

            # Angle between two turtles in radians
            angle = math.atan2(self.t1_pose.y - self.t2_pose.y,
                               self.t1_pose.x - self.t2_pose.x)
            # Need to subtract current angle of turtle2 to move relatively
            angular_speed = k_angular * (angle - self.t2_pose.theta)

            # resolution of 0.01
            if distance &gt; 0.01:
                self.twist.linear.x = linear_speed
                self.twist.angular.z = angular_speed
            else:
                self.twist.linear.x = 0
                self.twist.angular.z = 0

            # Publishing values on /turtle2/cmd_vel
            self.velocity_publisher.publish(self.twist)
            self.rate.sleep()

    # Destructor
    def __del__(self):
        # Unregister from rostopics
        self.t1_pose_subscriber.unregister()
        self.t2_pose_subscriber.unregister()
        rospy.loginfo(
            '\033[94m' + &quot;Object of class controlSimEnv Deleted.&quot; + '\033[0m')


def main():
    t = turtle()
    t.turtle_follow_turtle()


if __name__ == '__main__':
    try:
        main()
    except rospy.ROSInterruptException:
        pass
</code></pre>
<center><a href="tasks/task0/tasks/task0/node_catch_the_turtle.py" download><button>Download</button></a></center>
<hr />
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="autoeval-script"><a class="header" href="#autoeval-script">Autoeval script</a></h1>
<blockquote>
<p><strong>Note</strong>: Save this file in a ROS package scripts folder. Then to run this script, run in terminal <code>rosrun &lt;pkg-name&gt; autoeval.py</code>. This script generates a <code>results.csv</code> file showing the results.</p>
</blockquote>
<p><code>autoeval.py</code></p>
<pre><code class="language-python">#!/usr/bin/env python3
import glob
import rosbag
import math
import csv

# USAGE: rosrun pkg_task0 autoeval.py
# It will create a results.csv to the location where all bag_files is located.


def evaluate_score(bag):
    '''This method evaulates scores by looking into bag files. It then
    returns strings showing outcome.'''

    topics = bag.get_type_and_topic_info()[1].keys()
    if '/turtle1/pose' and '/turtle2/pose' and '/turtle1/cmd_vel' and '/turtle2/cmd_vel' in topics:
        is_topic_present = True
    else:
        is_topic_present = False

    t1_pos_msg_list = []
    t2_pos_msg_list = []

    for topic, msg, t in bag.read_messages(topics=['/turtle1/pose']):
        t1_pos_msg_list.append((t, msg))
    for topic, msg, t in bag.read_messages(topics=['/turtle2/pose']):
        t2_pos_msg_list.append((t, msg))

    dist_list = merge_list_with_calculated_distance(
        t1_pos_msg_list, t2_pos_msg_list)

    t1_cmd_vel_list = []
    t2_cmd_vel_list = []
    for topic, msg, t in bag.read_messages(topics=['/turtle1/cmd_vel']):
        t1_cmd_vel_list.append((t, msg))
    for topic, msg, t in bag.read_messages(topics=['/turtle2/cmd_vel']):
        t2_cmd_vel_list.append((t, msg))

    is_turtle2_running = is_turtle2_moving_when_turtle1_moves(
        t1_cmd_vel_list, t2_pos_msg_list)

    # Get the first publish timestamp of /turtle1/cmd_vel
    first_pub = t1_cmd_vel_list[0][0]

    # Find the closest value in the dist_list timestamp
    before_mov_t1 = min(dist_list, key=lambda list: abs(list[0] - first_pub))
    idx = dist_list.index(before_mov_t1)

    i = 1   # To ignore first element starting from 1 instead of 0
    count = 0   # Count the number of time distance is increasing.
    while i &lt; idx:
        if dist_list[i][1] &gt; dist_list[i-1][1]:
            count += 1
        i += 1
    percent_of_distance_increasing = (count * 100) / idx

    if dist_list[idx - 1][1] &lt; 0.05:
        is_reach_turtle1_spawn = True
    else:
        is_reach_turtle1_spawn = False

    if dist_list[-1][1] &lt; 0.05 and percent_of_distance_increasing &lt; 5 and is_turtle2_running:
        is_turtle2_following = True
    else:
        is_turtle2_following = False

    bag.close()
    return is_topic_present, is_reach_turtle1_spawn, is_turtle2_following


def calculate_distance(x0, y0, x1, y1):
    '''Calculate distance between two points in 2D. Input points (x0, y0) and
    (x1, y1).'''
    return math.sqrt((x0 - x1)**2 + (y0 - y1)**2)


def is_turtle2_moving_when_turtle1_moves(list1, list2):
    '''Check if turtle2 is running when turtle1 is moving. Return True
    if successful.'''
    closest_value = []
    # Create a list with timestamps similar to turtle1 moving out of turtle2
    # timestamps.
    for t, msg in list1:
        closest_value.append(min(
            list2, key=lambda list: abs(list[0] - t)))

    count = 0
    for t, msg in closest_value:
        if msg.linear_velocity == 0 and msg.angular_velocity == 0:
            count += 1
    # Currently it is set at 5 percent.
    if (count * 100) / len(closest_value) &lt; 5:
        return True
    else:
        return False


def merge_list_with_calculated_distance(list1, list2):
    '''Takes turtle1 and turtl2 position list with timestamps as arguments and
    return a list of distance between turtle1 and turtle2 with timestamps.'''
    l1 = [(t, msg, 1) for (t, msg) in list1]
    l2 = [(t, msg, 2) for (t, msg) in list2]
    new_list = l1 + l2
    # Sort list based on timestamps and index provided for t1 and t2 as 1, 2
    sorted_list = sorted(
        new_list, key=lambda element: (element[0], element[2]))
    c1 = list1[0][1]  # first value of msg
    c2 = list2[0][1]
    last_time = -1
    result = []
    for t, msg, index in sorted_list:
        if index == 1:
            c1 = msg
        elif index == 2:
            c2 = msg
        elif t == last_time:
            result.pop()
        result.append((t, calculate_distance(c1.x, c1.y, c2.x, c2.y)))
    return result


def get_remark(score):
    '''Returns the result based on success rate.'''
    if not score[0]:
        return &quot;Task Failed! Bag file doesn't have all topics.&quot;, False
    else:
        if not score[1]:
            return &quot;Task Failed! turtle2 Couldn't reach turtle1 at it's spawn position.&quot;, True
        else:
            if not score[2]:
                return &quot;Task Failed! Probably the bag file isn't complete.&quot;, True
            else:
                return &quot;Passed.&quot;, False


def main():
    bag_files = []
    # Change this path to where all bag files are located.
    path = &quot;/home/ubuntu/workspace/src/pkg_task0/bag_files&quot;
    for file in glob.glob(path + &quot;/*.bag&quot;):
        bag_files.append(file)

    print(bag_files)
    with open(path + '/' + 'results.csv', mode='w') as data_file:
        data_writer = csv.writer(data_file, delimiter=',',
                                 quotechar='&quot;', quoting=csv.QUOTE_MINIMAL)

        data_writer.writerow(['filename', 'Is turtle2 spawned?',
                             'Does turtle2 reach turtle1 spawn position?', 'Is turtle2 following turtle1?', 'Remark', 'Is Manual Evaluation required if a query is raised?'])
        for file in bag_files:
            bag = rosbag.Bag(file)
            score = evaluate_score(bag)
            remark = get_remark(score)
            data_writer.writerow(
                [file.split('/')[-1].split('.')[-2], score[0], score[1], score[2], remark[0], remark[1]])

    print(&quot;Finished creating csv file!&quot;)


if __name__ == '__main__':
    main()

</code></pre>
<center><a href="tasks/task0/tasks/task0/autoeval.py" download><button>Download</button></a><center>
<hr />

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
